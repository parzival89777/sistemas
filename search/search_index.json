{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introducci\u00f3n","text":""},{"location":"#bienvenido","title":"Bienvenido","text":"<p>Este es mi portafolio de evidencias para mis clases de sistemas embebidos 1 y proyecto de ingenieria IV, ambas de mi carrea de Ing. Mecatr\u00f3nica</p>"},{"location":"#sobre-mi","title":"Sobre mi","text":"<p>Mi nombre es Rodrigo Miranda Flores, aqu\u00ed encontraras mi documentaci\u00f3n sobre mis proyectos, ejercicios de clase y tareas con una breve explicaci\u00f3n, evidencias esperando te agrade y te sirva un poco.</p>"},{"location":"#contacto","title":"Contacto","text":"<ul> <li>Correo electronico: 199304@iberopuebla.mx</li> </ul>"},{"location":"Embedded%20Systems%20II/Activity%2001/","title":"\ud83d\udcda Activity 01","text":""},{"location":"Embedded%20Systems%20II/Activity%2001/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre: RTOS Tasks </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores, Jose Maria Meneses Avenda\u00f1o </li> <li>Curso / Asignatura: Embedded Systems II </li> <li>Fecha: 03/01/2026 </li> <li>Descripci\u00f3n breve: Solve the tasks 1-5 about RTOS.</li> </ul>"},{"location":"Embedded%20Systems%20II/Activity%2001/#excercise-1-identify-logical-tasks","title":"Excercise 1 \u2014 Identify Logical Tasks","text":"<p>List the logical tasks that exist in this system.</p> <p>Assume:</p> <ul> <li>The system runs on a microcontroller</li> <li>Timing matters</li> <li>Some operations may block (Wi-Fi, storage)</li> </ul> Task Name Trigger Periodic or Event-Based Reads a temperature sensor 50 ms timer Periodic Sends sensor data via Wi-Fi 2 s timer Periodic Monitors an emergency button Button press Event-Based Blinks a status LED 1 Hz Periodic Stores error messages Error event Event-Based"},{"location":"Embedded%20Systems%20II/Activity%2001/#excercise-2-task-characteristics","title":"Excercise 2 \u2014 Task Characteristics.","text":"<p>For each task you identified, answer the following:</p> <ul> <li>Is it time-critical? (Yes / No)</li> <li>Can it block safely? (Yes / No)</li> <li>What happens if this task is delayed?</li> </ul> <p>Write short, technical answers.</p> Task Time-Critical Block Safely Effect Reads a temperature sensor No Yes Sampling jitter increases, making trend analysis less reliable. Sends sensor data via Wi-Fi No No Other tasks may starve while the system waits for network completion. Monitors an emergency button Yes No The system may continue operating in an unsafe state longer than allowed. Blinks a status LED No Yes User feedback becomes misleading about the actual system state. Stores error messages No Yes Faults may occur without being traceable during post-mortem analysis."},{"location":"Embedded%20Systems%20II/Activity%2001/#excercise-3-priority-reasoning","title":"Excercise 3 \u2014 Priority Reasoning.","text":"<p>Assign a relative priority to each task:</p> <ul> <li>High</li> <li>Medium</li> <li>Low</li> </ul> <p>Then justify each choice in one sentence.</p> Task Priority (H/M/L) Justification Reads a temperature sensor Medium Late execution affects data quality but does not compromise system operation. Sends sensor data via Wi-Fi Medium Delays reduce data timeliness but do not immediately impact control logic. Monitors an emergency button High Any latency increases the time the system remains in a potentially dangerous state. Blinks a status LED Low Incorrect blinking only affects user perception, not system behavior. Stores error messages Low Post-event analysis may be incomplete without immediate logging."},{"location":"Embedded%20Systems%20II/Activity%2001/#excercise-4-design-judgment-trick-question","title":"Excercise 4 \u2014 Design Judgment (Trick Question).","text":"<p>Which of the following should NOT necessarily be implemented as a FreeRTOS task?</p> <ul> <li>Emergency button monitoring_</li> <li>Wi-Fi transmission_</li> <li>Error logging_</li> <li>Status LED blinking_</li> </ul> <p>Explain why in 2\u20133 sentences.</p> <p>Task that should not necessarily be implemented as a FreeRTOS task:</p> <ul> <li>Emergency button monitoring</li> </ul> <p>Explanation: Emergency button monitoring is better handled using a hardware interrupt to ensure immediate response. A FreeRTOS task can be notified afterward if additional processing is needed.</p>"},{"location":"Embedded%20Systems%20II/Activity%2001/#excercise-5-identifying-hidden-tasks-in-pseudo-code","title":"Excercise 5 \u2014 Identifying Hidden Tasks in Pseudo-Code.","text":"<p>The following pseudo-code represents a single-loop embedded program written without an RTOS.</p> <pre><code>while (1) {\n    read_temperature_sensor();          // takes ~2 ms\n\n    if (button_pressed()) {\n        emergency_shutdown();            // must react immediately\n    }\n\n    if (time_since_last_send() &gt; 2000) {\n        send_data_over_wifi();            // may block for 100\u2013300 ms\n    }\n\n    toggle_status_led();                 // 1 Hz blink rate\n\n    delay_ms(10);\n}\n</code></pre>"},{"location":"Embedded%20Systems%20II/Activity%2001/#exercise-51-identifying-hidden-tasks","title":"Exercise 5.1 \u2014 Identifying Hidden Tasks.","text":"Hidden Task Trigger (Time / Event) Why it should be a Task Reads a temperature sensor Periodic execution inside the loop A task keeps its execution independent from other code. Monitors an emergency button External event (button press) Task prioritization helps ensure fast reaction. Sends sensor data via Wi-Fi Time-based (every 2000 ms) A task isolates long communication delays. Blinks a status LED Periodic (Every 1 Hz) Task scheduling maintains a steady blink rate. Execution delay control Each loop iteration RTOS timing avoids blocking the entire program."},{"location":"Embedded%20Systems%20II/Activity%2001/#exercise-52-blocking-analysis","title":"Exercise 5.2 \u2014 Blocking Analysis","text":"<p>1) Which function can cause CPU blocking? - The Wi-Fi transmission routine, <code>send_data_over_wifi()</code>, as it can keep the CPU busy for several hundred milliseconds.</p> <p>2) Which parts of the system are affected while this blocking occurs? - Safety inputs are checked with noticeable delay. - The LED no longer toggles at a constant rate. - Sensor readings are postponed, reducing timing consistency.</p> <p>3) Which hidden task is the most exposed to this issue? - Emergency button processing, since any delay compromises the system\u2019s ability to react to critical events.</p>"},{"location":"Embedded%20Systems%20II/Activity%2001/#exercise-53-rtos-refactoring-thought-experiment","title":"Exercise 5.3 \u2014 RTOS Refactoring Thought Experiment**","text":"<p>Without writing code:</p> <p>Write short, technical justifications.</p> <p>1) Which hidden tasks should be implemented as FreeRTOS tasks?</p> <p>Sensor sampling should run as a dedicated task so its execution rate remains stable regardless of system load. Network transmission should also be isolated into its own task, since long blocking times can disrupt the rest of the system. LED control may be implemented as a low-priority task because it is periodic and has no functional impact on system safety.</p> <p>2) Which behavior should be handled using an interrupt?</p> <p>The emergency button should rely on an interrupt mechanism to ensure the shortest possible reaction time. This approach allows the system to respond immediately, even when other tasks are executing or blocked.</p> <p>3) Which task should have the highest priority, and why?</p> <p>Safety-related handling must run at the highest priority to guarantee immediate execution. Delaying this task could allow the system to continue operating in an unsafe condition.</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/Documentaci%C3%B3n%20final/","title":"\ud83d\udcdaDocumentaci\u00f3n","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Documentaci%C3%B3n%20final/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: YOLO-PARK </li> <li>Equipo / Autor(es):</li> </ul> <p>Rodrigo Miranda Flores </p> <p>Juan David Garcia Cortez</p> <p>Sumie Arai Erazo</p> <ul> <li>Curso / Asignatura: Proyecto de ingenieria IV </li> <li>Fecha: 05/12/2025 </li> <li>Descripci\u00f3n breve: En este apartado mostrar\u00e9 la documentaci\u00f3n final respecto a nuestro proyecto.</li> </ul>"},{"location":"Proyecto%20de%20ingenieria%20IV/Documentaci%C3%B3n%20final/#documentacion-final","title":"Documentaci\u00f3n final","text":"<p>Descargar PDF</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/Documentaci%C3%B3n%20final/#presentacion-final","title":"Presentaci\u00f3n final","text":"<p>Presentaci\u00f3n en l\u00ednea</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/Documentaci%C3%B3n%20final/#video-de-la-aplicacion","title":"Video de la aplicaci\u00f3n","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Documentaci%C3%B3n%20final/#video-de-la-inteligencia-artificial","title":"Video de la inteligencia artificial","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%201/","title":"\ud83d\udcda Semana 1","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%201/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: YOLO-PARK </li> <li>Equipo / Autor(es):</li> </ul> <p>Rodrigo Miranda Flores </p> <p>Juan David Garcia Cortez</p> <p>Sumie Arai Erazo</p> <ul> <li>Curso / Asignatura: Proyecto de ingenieria IV </li> <li>Fecha: 25/08/2025 </li> <li>Descripci\u00f3n breve: En este apartado mostrar\u00e9 los avances sobre nuestro proyecto .</li> </ul>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%201/#2-objetivo","title":"2) Objetivo","text":"<ul> <li>General: la optimizaci\u00f3n en la rotaci\u00f3n de veh\u00edculos, organizaci\u00f3n del flujo de tr\u00e1nsito y mejoramiento de la circulaci\u00f3n en \u00e1reas urbanas.</li> </ul>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%201/#presentacion","title":"Presentaci\u00f3n","text":"<p>Descargar PDF</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%203/","title":"\ud83d\udcda Semana 3","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%203/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: YOLO-PARK </li> <li>Equipo / Autor(es):</li> </ul> <p>Rodrigo Miranda Flores </p> <p>Juan David Garcia Cortez</p> <p>Sumie Arai Erazo</p> <ul> <li>Curso / Asignatura: Proyecto de ingenieria IV </li> <li>Fecha: 19/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra la tarea de el proyecto \"caf\u00e9 en c\u00e1psula\".</li> </ul>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%203/#historia-del-cafe-en-capsula","title":"Historia del caf\u00e9 en c\u00e1psula","text":"<p>El origen del caf\u00e9 expreso se remonta a principios del siglo XX en Italia. En 1901, Luigi Bezzera, desarroll\u00f3 un sistema para acelerar la preparaci\u00f3n del caf\u00e9 al incorporar vapor a presi\u00f3n en la cafetera. Este procedimiento no solo reduc\u00eda el tiempo de preparaci\u00f3n, sino que tambi\u00e9n produc\u00eda una bebida m\u00e1s concentrada y densa, pero no logr\u00f3 posicionar comercialmente su invento.</p> <p>En 1905, Desiderio Pavoni adquiri\u00f3 la patente de Bezzera. Con visi\u00f3n empresarial, introdujo la m\u00e1quina de expreso en el mercado italiano. Posteriormente, el desarrollo tecnol\u00f3gico continu\u00f3 en 1938, con Cremonesi, quien dise\u00f1\u00f3 una cafetera de pist\u00f3n que eliminaba el regusto a quemado derivado del uso de vapor o agua en ebullici\u00f3n y Achille Gaggia quien perfeccion\u00f3 la t\u00e9cnica al incorporar un pist\u00f3n de muelle que permit\u00eda aplicar presi\u00f3n al agua sin depender de la caldera de vapor. </p> <p>En 1961, la empresa Faema introdujo una innovaci\u00f3n clave: la m\u00e1quina de bomba el\u00e9ctrica. Este sistema hac\u00eda pasar agua a presi\u00f3n a trav\u00e9s del caf\u00e9, lo que dio origen al modelo de cafeteras de bomba, antecesoras directas de las cafeteras expreso modernas. Hacia mediados de la d\u00e9cada de 1970, el caf\u00e9 instant\u00e1neo gozaba de gran popularidad. En este contexto, el ingeniero suizo \u00c9ric Favre plante\u00f3 un nuevo desaf\u00edo: permitir que cualquier persona pudiera preparar en su hogar un expreso de calidad comparable al servido en cafeter\u00edas italianas. Favre trabaj\u00f3 en un sistema de c\u00e1psulas que denomin\u00f3 \u201cc\u00e9lula de extracci\u00f3n\u201d, cuyo dise\u00f1o concentraba los sabores y aromas del caf\u00e9. Su soluci\u00f3n t\u00e9cnica consisti\u00f3 inicialmente en una media esfera con un filtro y una membrana en la base. Posteriormente, modific\u00f3 el dise\u00f1o de manera que toda la c\u00e1psula actuara como filtro.</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%203/#avances-tecnologicos-y-diseno","title":"Avances tecnol\u00f3gicos y dise\u00f1o","text":"<p>Inicialmente las c\u00e1psulas de aluminio en su dise\u00f1o original (1995), pesaban 2 gramos con un contenido de caf\u00e9 de 3 gramos.Ten\u00eda una forma de media esfera y una base con filtro, dise\u00f1o que aun se usa en algunos modelos de c\u00e1psula en la actualidad.</p> <p>Favre tambi\u00e9n desarroll\u00f3 un envase para la c\u00e1psula con un dise\u00f1o de alta eficiencia. Este se compone de siete capas de polipropileno, lo que garantiza la conservaci\u00f3n del caf\u00e9 al tiempo que reduce la proporci\u00f3n de material de embalaje. El envoltorio representa solo el 12% del peso total de la c\u00e1psula, siendo el resto caf\u00e9.</p> <p>El resultado fue el sistema Monodor, que marc\u00f3 un hito en la preparaci\u00f3n dom\u00e9stica de caf\u00e9 expreso. Dado el potencial comercial de esta innovaci\u00f3n, Favre y su empresa, Monodor S.A., establecieron una s\u00f3lida estrategia de protecci\u00f3n de patentes para asegurar la exclusividad de su tecnolog\u00eda.</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%203/#nestle-estrategia","title":"Nestl\u00e9 estrategia","text":"<p>Nestl\u00e9 entr\u00f3 en este mercado con su empresa de caafeteras Nesspreso con un un inicio poco favorable. Sin embargo gracias a su estrategia de marketing con una experiencia explusiva para los consumidores, la patente sali\u00f3 a flote.</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%203/#presentacion","title":"Presentaci\u00f3n","text":"<p>Descargar PDF</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%204/","title":"\ud83d\udcda Semana 4","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%204/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: YOLO-PARK </li> <li>Equipo / Autor(es):</li> </ul> <p>Rodrigo Miranda Flores </p> <p>Juan David Garcia Cortez</p> <p>Sumie Arai Erazo</p> <ul> <li>Curso / Asignatura: Proyecto de ingenieria IV </li> <li>Fecha: 19/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra nuestro diagrama de Gantt respecto a nuestro proyecto\".</li> </ul>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%204/#diagrama-de-gantt","title":"Diagrama de Gantt","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%204/#vista-previa-del-diagrama-de-gantt","title":"Vista previa del diagrama de Gantt","text":"<p>Abrir el documento</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%205/","title":"\ud83d\udcda Semana 5","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%205/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: YOLO-PARK </li> <li>Equipo / Autor(es):</li> </ul> <p>Rodrigo Miranda Flores </p> <p>Juan David Garcia Cortez</p> <p>Sumie Arai Erazo</p> <ul> <li>Curso / Asignatura: Proyecto de ingenieria IV </li> <li>Fecha: 26/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra una de nuestras presentaci\u00f3nes respecto a nuestro proyecto\".</li> </ul>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%205/#presentacion","title":"Presentaci\u00f3n","text":"<p>Link</p> <p>Descargar PDF</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%206/","title":"\ud83d\udcda Semana 6","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%206/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: YOLO-PARK </li> <li>Equipo / Autor(es):</li> </ul> <p>Rodrigo Miranda Flores </p> <p>Juan David Garcia Cortez</p> <p>Sumie Arai Erazo</p> <ul> <li>Curso / Asignatura: Proyecto de ingenieria IV </li> <li>Fecha: 03/10/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra nuestra presentaci\u00f3n de Segmentaci\u00f3n y fuerzas de porter\".</li> </ul>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%206/#presentacion","title":"Presentaci\u00f3n","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%207/","title":"\ud83d\udcda Semana 7","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%207/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: YOLO-PARK </li> <li>Equipo / Autor(es):</li> </ul> <p>Rodrigo Miranda Flores </p> <p>Juan David Garcia Cortez</p> <p>Sumie Arai Erazo</p> <ul> <li>Curso / Asignatura: Proyecto de ingenieria IV </li> <li>Fecha: 10/10/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra nuestra presentaci\u00f3n sobre los costos planeados para nuestro proyecto\".</li> </ul>"},{"location":"Proyecto%20de%20ingenieria%20IV/Semana%207/#presentacion-adicional","title":"Presentaci\u00f3n adicional","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Syllabus/","title":"\ud83d\udcda Syllabus","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/Syllabus/#syllabus-firmado","title":"Syllabus Firmado","text":"<p>Descargar PDF</p>"},{"location":"Sistemas%20embebidos%20l/Examen%201/","title":"\ud83d\udcda Examen 1","text":""},{"location":"Sistemas%20embebidos%20l/Examen%201/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Sim\u00f3n Dice (4 colores) \u2013 RP Pico 2 </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 22/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra mi primer examen el cual es el juego \"Sim\u00f3n dice\" con 4 leds de diferentes colores, todo programado con una Raspberry pi pico2.</li> </ul>"},{"location":"Sistemas%20embebidos%20l/Examen%201/#ejercicio-1","title":"Ejercicio 1","text":"<p>1) Que debe hacer:</p> <ul> <li> <p>Construir un juego Sim\u00f3n Dice de 4 colores en Raspberry Pi Pico 2.</p> </li> <li> <p>La secuencia crece +1 por ronda, de 1 hasta 15.</p> </li> <li> <p>La persona jugadora debe repetir la secuencia con 4 botones dentro de un tiempo l\u00edmite por ronda.</p> </li> <li> <p>Tiempo l\u00edmite por ronda (fase de entrada): TL = longitud + 5 segundos (p. ej., Ronda 7 \u2192 12 s).</p> </li> <li> <p>Puntaje (0\u201315): mostrar la m\u00e1xima ronda alcanzada en un display de 7 segmentos en hex (0\u20139, A, b, C, d, E, F).</p> </li> <li> <p>Aleatoriedad obligatoria: la secuencia debe ser impredecible en cada ejecuci\u00f3n.</p> </li> </ul> <p>2) Reglas del juego</p> <ul> <li> <p>Encendido/Reset: el 7 segmentos muestra \u201c0\u201d y queda en espera de Start (cualquier bot\u00f3n permite iniciar).</p> </li> <li> <p>Reproducci\u00f3n: mostrar la secuencia actual (LEDs uno por uno con separaci\u00f3n clara).</p> </li> <li> <p>Entrada: al terminar la reproducci\u00f3n, la persona debe repetir la secuencia completa dentro de TL.</p> </li> <li> <p>Fallo (Game Over): bot\u00f3n incorrecto, falta/extra de entradas o exceder TL.</p> </li> <li> <p>Progresi\u00f3n: si acierta, puntaje = n\u00famero de ronda, agrega 1 color aleatorio y avanza.</p> </li> <li> <p>Fin: al fallar o completar la Ronda 15. Mostrar puntaje final en 7 segmentos (hex).</p> </li> </ul> <p>3) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/timer.h\"\n#include &lt;stdlib.h&gt;\n\n\n#define LED_RED    0\n#define LED_GREEN  1\n#define LED_BLUE   2\n#define LED_YELLOW 3\n\n#define BTN_RED    4\n#define BTN_GREEN  5\n#define BTN_BLUE   6\n#define BTN_YELLOW 7\n\n#define SEG_A 8\n#define SEG_B 9\n#define SEG_C 10\n#define SEG_D 11\n#define SEG_E 12\n#define SEG_F 13\n#define SEG_G 14\n#define SEG_DP 15\n\n#define MAX_RONDA 15\n\n//Estado del juego\nuint8_t secuencia[MAX_RONDA];  //secuencia de colores (0\u20133)\nuint8_t ronda_actual = 0;\n\n//Mapeo de LEDs y botones\nconst uint8_t leds[4] = {LED_RED, LED_GREEN, LED_BLUE, LED_YELLOW};\nconst uint8_t botones[4] = {BTN_RED, BTN_GREEN, BTN_BLUE, BTN_YELLOW};\n\n//Tabla de 7 segmentos (0\u2013F)\nconst uint8_t tabla7seg[16] = {\n    0b0111111, // 0\n    0b0000110, // 1\n    0b1011011, // 2\n    0b1001111, // 3\n    0b1100110, // 4\n    0b1101101, // 5\n    0b1111101, // 6\n    0b0000111, // 7\n    0b1111111, // 8\n    0b1101111, // 9\n    0b1110111, // A\n    0b1111100, // b\n    0b0111001, // C\n    0b1011110, // d\n    0b1111001, // E\n    0b1110001  // F\n};\n\n//Inicializaci\u00f3n\nvoid init_leds() {\n    for(int i=0;i&lt;4;i++) {\n        gpio_init(leds[i]);\n        gpio_set_dir(leds[i], GPIO_OUT);\n        gpio_put(leds[i],0);\n    }\n}\n\nvoid init_botones() {\n    for(int i=0;i&lt;4;i++) {\n        gpio_init(botones[i]);\n        gpio_set_dir(botones[i], GPIO_IN);\n        gpio_pull_up(botones[i]);\n    }\n}\n\nvoid init_display() {\n    for(int i=SEG_A;i&lt;=SEG_G;i++){\n        gpio_init(i);\n        gpio_set_dir(i, GPIO_OUT);\n        gpio_put(i,0);\n    }\n}\n\n//Mostrar en 7 segmentos\nvoid mostrar_hex(uint8_t val){\n    uint8_t mask = tabla7seg[val &amp; 0x0F];\n    for(int i=0;i&lt;7;i++){\n        gpio_put(SEG_A+i, (mask&gt;&gt;i)&amp;1);\n    }\n}\n\n//Reproducir secuencia\nvoid reproducir_secuencia(uint8_t longitud){\n    for(int i=0;i&lt;longitud;i++){\n        gpio_put(leds[secuencia[i]],1);\n        sleep_ms(500);\n        gpio_put(leds[secuencia[i]],0);\n        sleep_ms(250);\n    }\n}\n\n//Leer entrada del jugador con l\u00edmite de tiempo\nbool leer_entrada(uint8_t ronda){\n    uint32_t inicio = to_us_since_boot(get_absolute_time());\n    uint32_t limite = (ronda + 5) * 1000000u; //tiempo l\u00edmite en \u00b5s\n\n    for(int i = 0; i &lt; ronda; i++){\n        bool respondio = false;\n        while(to_us_since_boot(get_absolute_time()) - inicio &lt; limite){\n            for(int j = 0; j &lt; 4; j++){\n                if(!gpio_get(botones[j])){ //bot\u00f3n presionado\n                    sleep_ms(50); //debouncing\n                    if(!gpio_get(botones[j])){ //sigue presionado\n                        if(j == secuencia[i]){\n                            respondio = true; //fue correcto\n                        } else {\n                            //Bot\u00f3n incorrecto \u2192 Game Over\n                            return false;\n                        }\n\n                        //esperar hasta que TODOS los botones est\u00e9n liberados\n                        bool todos_sueltos = false;\n                        while(!todos_sueltos){\n                            todos_sueltos = true;\n                            for(int k = 0; k &lt; 4; k++){\n                                if(!gpio_get(botones[k])) todos_sueltos = false;\n                            }\n                            sleep_ms(10);\n                        }\n                        break;\n                    }\n                }\n            }\n            if(respondio) break; //salir del while\n        }\n        if(!respondio){\n            //Timeout \u2192 Game Over\n            return false;\n        }\n    }\n    return true; //toda la secuencia correcta\n}\n\n\n//Agregar nuevo color aleatorio\nvoid agregar_color(){\n    secuencia[ronda_actual] = rand()%4;\n    ronda_actual++;\n}\n\n//Main\nint main(){\n    stdio_init_all();\n    init_leds();\n    init_botones();\n    init_display();\n    mostrar_hex(0); //espera de inicio\n\n    while(true){\n        //esperar bot\u00f3n para iniciar\n        while(gpio_get(BTN_RED) &amp;&amp; gpio_get(BTN_GREEN) &amp;&amp;\n              gpio_get(BTN_BLUE) &amp;&amp; gpio_get(BTN_YELLOW)){\n            tight_loop_contents();\n        }\n\n        ronda_actual=0;\n        srand(to_us_since_boot(get_absolute_time())); // semilla aleatoria\n        agregar_color(); //primer color\n\n       while(ronda_actual &lt;= MAX_RONDA){\n    mostrar_hex(ronda_actual);\n    reproducir_secuencia(ronda_actual);\n\n    if(!leer_entrada(ronda_actual)){\n        //Game Over: reiniciar a estado inicial\n        ronda_actual = 0;\n        mostrar_hex(0);\n\n        //esperar nuevo bot\u00f3n para empezar de cero\n        while(gpio_get(BTN_RED) &amp;&amp; gpio_get(BTN_GREEN) &amp;&amp;\n              gpio_get(BTN_BLUE) &amp;&amp; gpio_get(BTN_YELLOW)){\n            tight_loop_contents();\n        }\n\n        srand(to_us_since_boot(get_absolute_time())); // nueva semilla\n        agregar_color(); //nueva secuencia desde 1\n        continue; //volver a empezar\n    }\n\n    if(ronda_actual == MAX_RONDA) break; //Ronda 15 completada\n\n    agregar_color(); //siguiente ronda\n}\n\n        //Victoria: parpadear LEDs y mostrar 'F' en 7 segmentos\n        for(int i=0;i&lt;5;i++){\n            for(int j=0;j&lt;4;j++) gpio_put(leds[j],1);\n            mostrar_hex(0xF);\n            sleep_ms(500);\n            for(int j=0;j&lt;4;j++) gpio_put(leds[j],0);\n            mostrar_hex(0);\n            sleep_ms(500);\n        }\n\n        //esperar nuevo bot\u00f3n para empezar de cero\n        while(gpio_get(BTN_RED) &amp;&amp; gpio_get(BTN_GREEN) &amp;&amp;\n              gpio_get(BTN_BLUE) &amp;&amp; gpio_get(BTN_YELLOW)){\n            tight_loop_contents();\n        }\n    }\n\n    return 0;\n}\n</code></pre></p> <p>4) Esquematico de conexion: </p> <p>5) Video:</p>"},{"location":"Sistemas%20embebidos%20l/Examen%202/","title":"\ud83d\udcda Examen 2","text":""},{"location":"Sistemas%20embebidos%20l/Examen%202/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Control de un Servomotor </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 22/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra mi segundo examen sobre el control de Servomotores con comandos.</li> </ul>"},{"location":"Sistemas%20embebidos%20l/Examen%202/#control-de-servomotores-con-comandos","title":"Control de Servomotores con comandos","text":"<p>1) Hardware m\u00ednimo</p> <ul> <li> <p>1 \u00d7 servomotor en un pin PWM (50 Hz).</p> </li> <li> <p>3 \u00d7 botones:</p> </li> <li> <p>BTN_MODE: cambia el modo activo (c\u00edclico: Entrenamiento \u2192 Continuo \u2192 Step \u2192 \u2026).</p> </li> <li> <p>BTN_NEXT: avanza a la siguiente posici\u00f3n (s\u00f3lo en Step).</p> </li> <li> <p>BTN_PREV: retrocede a la posici\u00f3n anterior (s\u00f3lo en Step).</p> </li> <li>Pi pico 2</li> </ul> <p>2) Que debe hacer:</p> <p>Modo Entrenamiento</p> <ul> <li> <p>Se recibe texto por USB-serial con los comandos siguientes (se aceptan min\u00fasculas/may\u00fasculas indistintamente y tambi\u00e9n sus alias en ingl\u00e9s):</p> </li> <li> <p>Borrar (alias: clear, borrar)</p> </li> <li> <p>Sintaxis: Borrar</p> </li> <li> <p>Efecto: elimina la lista completa de posiciones.</p> </li> <li> <p>Respuesta: OK.</p> </li> </ul> <p>Escribir (alias: write, escribir)</p> <ul> <li> <p>Sintaxis: Escribir, v1, v2, ..., vn</p> </li> <li> <p>vi son enteros en 0\u2013180.</p> </li> <li> <p>fecto: sobrescribe la lista con los valores dados en ese orden.</p> </li> <li>Respuesta: OK si todos son v\u00e1lidos y la lisa de posiciones; si alguno est\u00e1 fuera de rango o la lista queda vac\u00eda \u2192 Error argumento invalido.</li> </ul> <p>Reemplazar (alias: replace, reemplazar)</p> <ul> <li> <p>Sintaxis: Reemplazar, i, v</p> </li> <li> <p>\u00cdndice i en base 1 (1 = primera posici\u00f3n).</p> </li> <li> <p>v en 0\u2013180.</p> </li> <li> <p>Efecto: reemplaza el elemento i por v.</p> </li> <li> <p>Respuesta: OK. Si i no existe \u2192 Error indice invalido. Si v fuera de rango \u2192 Error argumento invalido.</p> </li> </ul> <p>Modo Continuo - Recorre todas las posiciones de la lista en orden, moviendo el servo e imprimiendo cada 1.5 s:</p> <ul> <li> <p>Formato: posX: V (por ejemplo, pos1: 90), donde X es base 1.</p> </li> <li> <p>Si la lista est\u00e1 vac\u00eda: imprimir cada 1.5 s Error no hay pos y no mover el servo.</p> </li> <li> <p>Al cambiar a otro modo, el ciclo se detiene inmediatamente.</p> </li> </ul> <p>Modo Step - BTN_NEXT: avanza una posici\u00f3n (si ya est\u00e1 en la \u00faltima, se mantiene en esa \u00faltima).</p> <ul> <li> <p>BTN_PREV: retrocede una posici\u00f3n (si ya est\u00e1 en la primera, se mantiene en la primera).</p> </li> <li> <p>En cada cambio de posici\u00f3n:</p> </li> <li> <p>mover el servo a la posici\u00f3n seleccionada;</p> </li> <li> <p>imprimir posX: V.</p> </li> <li> <p>Si la lista est\u00e1 vac\u00eda: al presionar BTN_NEXT o BTN_PREV, imprimir Error no hay pos y no mover el servo.</p> </li> </ul> <p>INFO IMPORTANTE: El movimiento de un servo requiere alimentacion 5-6v y en el pin de signal, un pwm a 50 HZ con un pulso de 1-2ms que representa 0-180 grados.</p> <p>3) Codigo: <pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;string&gt;\n\nusing namespace std;\n\n// CONFIGURACI\u00d3N UART Y PINES\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n\n#define SERVO_PIN 2\nconst uint BTNMODE = 3;\nconst uint BTNNEXT = 4;\nconst uint BTNPREV = 5;\n\n// VARIABLES GLOBALES\nint valores_guardados[10] = {0};\nint cantidad_posiciones = 0;\n\nvoid borrar_lista() {\n    for (int i = 0; i &lt; 10; i++) valores_guardados[i] = 0;\n    cantidad_posiciones = 0;\n    printf(\"OK. Lista borrada.\\n\");\n}\n\nuint16_t angle_to_level(uint16_t angle) {\n    float pulse_us = 1000.0f + (angle * 1000.0f / 180.0f);\n    return (uint16_t)((pulse_us / 20000.0f) * 65535);\n}\n\n// PROGRAMA PRINCIPAL\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"Modo de entrenamiento activado\\n\");\n    printf(\"Comandos: escribir, reemplazar, borrar\\n\");\n\n    // UART\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    // PWM (Servo)\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SERVO_PIN);\n    uint chan  = pwm_gpio_to_channel(SERVO_PIN);\n    pwm_set_wrap(slice, 65535);\n    float f_clk = 125000000.0f;\n    float div = f_clk / (50.0f * 65536.0f);\n    pwm_set_clkdiv(slice, div);\n    pwm_set_enabled(slice, true);\n\n    // Botones\n    gpio_init(BTNMODE); gpio_set_dir(BTNMODE, GPIO_IN); gpio_pull_up(BTNMODE);\n    gpio_init(BTNNEXT); gpio_set_dir(BTNNEXT, GPIO_IN); gpio_pull_up(BTNNEXT);\n    gpio_init(BTNPREV); gpio_set_dir(BTNPREV, GPIO_IN); gpio_pull_up(BTNPREV);\n\n    string mensaje_usb = \"\";\n    int modo_index = 0;\n    int modo_actual = 1;   // 1=Entrenamiento, 2=Continuo, 3=Step\n    bool btnmode_presionado = false, btnnext_presionado = false, btnprev_presionado = false;\n    bool ciclo_activo = false;\n\n    while (true) {\n        // LECTURA USB\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!mensaje_usb.empty()) {\n                    string comando = mensaje_usb;\n                    mensaje_usb = \"\";\n\n                    // BORRAR\n                    if (comando == \"borrar\" || comando == \"clear\" || comando == \"Borrar\" || comando == \"Clear\") {\n                        borrar_lista();\n                    }\n\n                    // ESCRIBIR\n                    else if (comando == \"escribir\" || comando == \"write\" || comando == \"Escribir\" || comando == \"Write\") {\n                        printf(\"Ingresa valores separados por comas (ej: 10,45,90,... m\u00e1x 10):\\n\");\n                        string entrada_valores = \"\";\n                        while (true) {\n                            int c2 = getchar_timeout_us(0);\n                            if (c2 != PICO_ERROR_TIMEOUT) {\n                                if (c2 == '\\n' || c2 == '\\r') break;\n                                entrada_valores += (char)c2;\n                            }\n                        }\n\n                        // Procesar entrada\n                        int i = 0; string temp = \"\"; bool error = false;\n                        for (char c : entrada_valores) {\n                            if (c == ',') {\n                                if (i &lt; 10) {\n                                    int val = stoi(temp);\n                                    if (val &lt; 0 || val &gt; 180) { error = true; break; }\n                                    valores_guardados[i++] = val;\n                                    temp = \"\";\n                                } else { error = true; break; }\n                            } else temp += c;\n                        }\n                        if (!temp.empty() &amp;&amp; i &lt; 10) {\n                            int val = stoi(temp);\n                            if (val &lt; 0 || val &gt; 180) error = true;\n                            else valores_guardados[i++] = val;\n                        }\n\n                        cantidad_posiciones = i;\n\n                        if (cantidad_posiciones &lt; 1 || cantidad_posiciones &gt; 10) {\n                            printf(\"Cantidad de posiciones invalida\\n\");\n                            borrar_lista();\n                        } else if (error) {\n                            printf(\"Error argumento invalido\\n\");\n                            borrar_lista();\n                        } else {\n                            printf(\"OK. Lista: \");\n                            for (int j = 0; j &lt; cantidad_posiciones; j++) {\n                                printf(\"%d%s\", valores_guardados[j], (j &lt; cantidad_posiciones-1) ? \", \" : \"\\n\");\n                            }\n                        }\n                    }\n\n                    // REEMPLAZAR\n                    else if (comando == \"reemplazar\" || comando == \"replace\" || comando == \"Reemplazar\" || comando == \"Replace\") {\n                        printf(\"Formato: reemplazar,i,v (ej: 2,130)\\n\");\n                        string entrada_replace = \"\";\n                        while (true) {\n                            int c2 = getchar_timeout_us(0);\n                            if (c2 != PICO_ERROR_TIMEOUT) {\n                                if (c2 == '\\n' || c2 == '\\r') break;\n                                entrada_replace += (char)c2;\n                            }\n                        }\n\n                        int pos=-1, val=-1; string temp=\"\"; bool sep=false;\n                        for (char c : entrada_replace) {\n                            if (c == ',' &amp;&amp; !sep) { pos = stoi(temp)-1; temp=\"\"; sep=true; }\n                            else temp+=c;\n                        }\n                        if (sep &amp;&amp; !temp.empty()) val = stoi(temp);\n\n                        if (pos&lt;0 || pos&gt;=cantidad_posiciones) printf(\"Error indice invalido\\n\");\n                        else if (val&lt;0 || val&gt;180) printf(\"Error argumento invalido\\n\");\n                        else {\n                            valores_guardados[pos]=val;\n                            printf(\"OK. pos%d = %d\\n\", pos+1, val);\n                        }\n                    }\n\n                    else {\n                        printf(\"Comando no reconocido\\n\");\n                    }\n                }\n            } else mensaje_usb += (char)ch;\n        }\n\n        // LECTURA BOTONES\n        bool bmode = gpio_get(BTNMODE)==0;\n        bool bnext = gpio_get(BTNNEXT)==0;\n        bool bprev = gpio_get(BTNPREV)==0;\n\n        // CAMBIO DE MODO\n        if (bmode &amp;&amp; !btnmode_presionado) {\n            modo_actual++;\n            if (modo_actual &gt; 3) modo_actual = 1;\n            printf(\"Cambio a modo %d\\n\", modo_actual);\n            ciclo_activo = (modo_actual == 2);\n            btnmode_presionado = true;\n        } else if (!bmode) btnmode_presionado = false;\n\n        // MODO 2: CONTINUO\n        if (modo_actual == 2 &amp;&amp; ciclo_activo) {\n            if (cantidad_posiciones &lt; 1) {\n                printf(\"Error no hay pos\\n\");\n                sleep_ms(1500);\n            } else {\n                for (int i=0; i&lt;cantidad_posiciones; i++) {\n                    pwm_set_chan_level(slice, chan, angle_to_level(valores_guardados[i]));\n                    printf(\"pos%d: %d\\n\", i+1, valores_guardados[i]);\n                    for (int t=0; t&lt;15; t++) {\n                        sleep_ms(100);\n                        if (modo_actual != 2) break;\n                    }\n                    if (modo_actual != 2) break;\n                }\n            }\n        }\n\n        // MODO 3: STEP\n        if (modo_actual == 3) {\n            if (cantidad_posiciones &lt; 1) {\n                if (bnext || bprev) printf(\"Error no hay pos\\n\");\n            } else {\n                if (bnext &amp;&amp; !btnnext_presionado) {\n                    if (modo_index &lt; cantidad_posiciones-1) modo_index++;\n                    pwm_set_chan_level(slice, chan, angle_to_level(valores_guardados[modo_index]));\n                    printf(\"pos%d: %d\\n\", modo_index+1, valores_guardados[modo_index]);\n                    btnnext_presionado = true;\n                } else if (!bnext) btnnext_presionado = false;\n\n                if (bprev &amp;&amp; !btnprev_presionado) {\n                    if (modo_index &gt; 0) modo_index--;\n                    pwm_set_chan_level(slice, chan, angle_to_level(valores_guardados[modo_index]));\n                    printf(\"pos%d: %d\\n\", modo_index+1, valores_guardados[modo_index]);\n                    btnprev_presionado = true;\n                } else if (!bprev) btnprev_presionado = false;\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre></p> <p>4) Esquematico de conexion: </p> <p>5) Video:</p>"},{"location":"Sistemas%20embebidos%20l/Examen_1/","title":"\ud83d\udcda Examen 1","text":""},{"location":"Sistemas%20embebidos%20l/Examen_1/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Sim\u00f3n Dice (4 colores) \u2013 RP Pico 2 </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 22/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra mi primer examen el cual es el juego \"Sim\u00f3n dice\" con 4 leds de diferentes colores, todo programado con una Raspberry pi pico2.</li> </ul>"},{"location":"Sistemas%20embebidos%20l/Examen_1/#ejercicio-1","title":"Ejercicio 1","text":"<p>1) Que debe hacer:</p> <ul> <li> <p>Construir un juego Sim\u00f3n Dice de 4 colores en Raspberry Pi Pico 2.</p> </li> <li> <p>La secuencia crece +1 por ronda, de 1 hasta 15.</p> </li> <li> <p>La persona jugadora debe repetir la secuencia con 4 botones dentro de un tiempo l\u00edmite por ronda.</p> </li> <li> <p>Tiempo l\u00edmite por ronda (fase de entrada): TL = longitud + 5 segundos (p. ej., Ronda 7 \u2192 12 s).</p> </li> <li> <p>Puntaje (0\u201315): mostrar la m\u00e1xima ronda alcanzada en un display de 7 segmentos en hex (0\u20139, A, b, C, d, E, F).</p> </li> <li> <p>Aleatoriedad obligatoria: la secuencia debe ser impredecible en cada ejecuci\u00f3n.</p> </li> </ul> <p>2) Reglas del juego</p> <ul> <li> <p>Encendido/Reset: el 7 segmentos muestra \u201c0\u201d y queda en espera de Start (cualquier bot\u00f3n permite iniciar).</p> </li> <li> <p>Reproducci\u00f3n: mostrar la secuencia actual (LEDs uno por uno con separaci\u00f3n clara).</p> </li> <li> <p>Entrada: al terminar la reproducci\u00f3n, la persona debe repetir la secuencia completa dentro de TL.</p> </li> <li> <p>Fallo (Game Over): bot\u00f3n incorrecto, falta/extra de entradas o exceder TL.</p> </li> <li> <p>Progresi\u00f3n: si acierta, puntaje = n\u00famero de ronda, agrega 1 color aleatorio y avanza.</p> </li> <li> <p>Fin: al fallar o completar la Ronda 15. Mostrar puntaje final en 7 segmentos (hex).</p> </li> </ul> <p>3) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/timer.h\"\n#include &lt;stdlib.h&gt;\n\n\n#define LED_RED    0\n#define LED_GREEN  1\n#define LED_BLUE   2\n#define LED_YELLOW 3\n\n#define BTN_RED    4\n#define BTN_GREEN  5\n#define BTN_BLUE   6\n#define BTN_YELLOW 7\n\n#define SEG_A 8\n#define SEG_B 9\n#define SEG_C 10\n#define SEG_D 11\n#define SEG_E 12\n#define SEG_F 13\n#define SEG_G 14\n#define SEG_DP 15\n\n#define MAX_RONDA 15\n\n//Estado del juego\nuint8_t secuencia[MAX_RONDA];  //secuencia de colores (0\u20133)\nuint8_t ronda_actual = 0;\n\n//Mapeo de LEDs y botones\nconst uint8_t leds[4] = {LED_RED, LED_GREEN, LED_BLUE, LED_YELLOW};\nconst uint8_t botones[4] = {BTN_RED, BTN_GREEN, BTN_BLUE, BTN_YELLOW};\n\n//Tabla de 7 segmentos (0\u2013F)\nconst uint8_t tabla7seg[16] = {\n    0b0111111, // 0\n    0b0000110, // 1\n    0b1011011, // 2\n    0b1001111, // 3\n    0b1100110, // 4\n    0b1101101, // 5\n    0b1111101, // 6\n    0b0000111, // 7\n    0b1111111, // 8\n    0b1101111, // 9\n    0b1110111, // A\n    0b1111100, // b\n    0b0111001, // C\n    0b1011110, // d\n    0b1111001, // E\n    0b1110001  // F\n};\n\n//Inicializaci\u00f3n\nvoid init_leds() {\n    for(int i=0;i&lt;4;i++) {\n        gpio_init(leds[i]);\n        gpio_set_dir(leds[i], GPIO_OUT);\n        gpio_put(leds[i],0);\n    }\n}\n\nvoid init_botones() {\n    for(int i=0;i&lt;4;i++) {\n        gpio_init(botones[i]);\n        gpio_set_dir(botones[i], GPIO_IN);\n        gpio_pull_up(botones[i]);\n    }\n}\n\nvoid init_display() {\n    for(int i=SEG_A;i&lt;=SEG_G;i++){\n        gpio_init(i);\n        gpio_set_dir(i, GPIO_OUT);\n        gpio_put(i,0);\n    }\n}\n\n//Mostrar en 7 segmentos\nvoid mostrar_hex(uint8_t val){\n    uint8_t mask = tabla7seg[val &amp; 0x0F];\n    for(int i=0;i&lt;7;i++){\n        gpio_put(SEG_A+i, (mask&gt;&gt;i)&amp;1);\n    }\n}\n\n//Reproducir secuencia\nvoid reproducir_secuencia(uint8_t longitud){\n    for(int i=0;i&lt;longitud;i++){\n        gpio_put(leds[secuencia[i]],1);\n        sleep_ms(500);\n        gpio_put(leds[secuencia[i]],0);\n        sleep_ms(250);\n    }\n}\n\n//Leer entrada del jugador con l\u00edmite de tiempo\nbool leer_entrada(uint8_t ronda){\n    uint32_t inicio = to_us_since_boot(get_absolute_time());\n    uint32_t limite = (ronda + 5) * 1000000u; //tiempo l\u00edmite en \u00b5s\n\n    for(int i = 0; i &lt; ronda; i++){\n        bool respondio = false;\n        while(to_us_since_boot(get_absolute_time()) - inicio &lt; limite){\n            for(int j = 0; j &lt; 4; j++){\n                if(!gpio_get(botones[j])){ //bot\u00f3n presionado\n                    sleep_ms(50); //debouncing\n                    if(!gpio_get(botones[j])){ //sigue presionado\n                        if(j == secuencia[i]){\n                            respondio = true; //fue correcto\n                        } else {\n                            //Bot\u00f3n incorrecto \u2192 Game Over\n                            return false;\n                        }\n\n                        //esperar hasta que TODOS los botones est\u00e9n liberados\n                        bool todos_sueltos = false;\n                        while(!todos_sueltos){\n                            todos_sueltos = true;\n                            for(int k = 0; k &lt; 4; k++){\n                                if(!gpio_get(botones[k])) todos_sueltos = false;\n                            }\n                            sleep_ms(10);\n                        }\n                        break;\n                    }\n                }\n            }\n            if(respondio) break; //salir del while\n        }\n        if(!respondio){\n            //Timeout \u2192 Game Over\n            return false;\n        }\n    }\n    return true; //toda la secuencia correcta\n}\n\n\n//Agregar nuevo color aleatorio\nvoid agregar_color(){\n    secuencia[ronda_actual] = rand()%4;\n    ronda_actual++;\n}\n\n//Main\nint main(){\n    stdio_init_all();\n    init_leds();\n    init_botones();\n    init_display();\n    mostrar_hex(0); //espera de inicio\n\n    while(true){\n        //esperar bot\u00f3n para iniciar\n        while(gpio_get(BTN_RED) &amp;&amp; gpio_get(BTN_GREEN) &amp;&amp;\n              gpio_get(BTN_BLUE) &amp;&amp; gpio_get(BTN_YELLOW)){\n            tight_loop_contents();\n        }\n\n        ronda_actual=0;\n        srand(to_us_since_boot(get_absolute_time())); // semilla aleatoria\n        agregar_color(); //primer color\n\n       while(ronda_actual &lt;= MAX_RONDA){\n    mostrar_hex(ronda_actual);\n    reproducir_secuencia(ronda_actual);\n\n    if(!leer_entrada(ronda_actual)){\n        //Game Over: reiniciar a estado inicial\n        ronda_actual = 0;\n        mostrar_hex(0);\n\n        //esperar nuevo bot\u00f3n para empezar de cero\n        while(gpio_get(BTN_RED) &amp;&amp; gpio_get(BTN_GREEN) &amp;&amp;\n              gpio_get(BTN_BLUE) &amp;&amp; gpio_get(BTN_YELLOW)){\n            tight_loop_contents();\n        }\n\n        srand(to_us_since_boot(get_absolute_time())); // nueva semilla\n        agregar_color(); //nueva secuencia desde 1\n        continue; //volver a empezar\n    }\n\n    if(ronda_actual == MAX_RONDA) break; //Ronda 15 completada\n\n    agregar_color(); //siguiente ronda\n}\n\n        //Victoria: parpadear LEDs y mostrar 'F' en 7 segmentos\n        for(int i=0;i&lt;5;i++){\n            for(int j=0;j&lt;4;j++) gpio_put(leds[j],1);\n            mostrar_hex(0xF);\n            sleep_ms(500);\n            for(int j=0;j&lt;4;j++) gpio_put(leds[j],0);\n            mostrar_hex(0);\n            sleep_ms(500);\n        }\n\n        //esperar nuevo bot\u00f3n para empezar de cero\n        while(gpio_get(BTN_RED) &amp;&amp; gpio_get(BTN_GREEN) &amp;&amp;\n              gpio_get(BTN_BLUE) &amp;&amp; gpio_get(BTN_YELLOW)){\n            tight_loop_contents();\n        }\n    }\n\n    return 0;\n}\n</code></pre></p> <p>4) Esquematico de conexion: </p> <p>5) Video:</p>"},{"location":"Sistemas%20embebidos%20l/Micromouse/","title":"\ud83d\udcda Proyecto Final","text":""},{"location":"Sistemas%20embebidos%20l/Micromouse/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Micromouse </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 08/12/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestran la creaci\u00f3n de un micromouse.</li> </ul> <p>1) Que debe hacer: El micromouse tiene como tarea resolver un laberinto de forma autonoma y eficiente.</p>"},{"location":"Sistemas%20embebidos%20l/Micromouse/#fase-1-pruebas","title":"Fase 1 - Pruebas","text":"<p>1) Descripci\u00f3n breve: El micromouse fue practicado en una protoboard para probar funcionamiento de motores, sensores, pila y circuito.</p> <p>2) Codigos:</p> <ul> <li> <p>Prueba de motores y sensores <pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/timer.h\"\n\nconst uint STBY = 10;\nconst uint PWMA = 6, AIN1 = 7, AIN2 = 8;\nconst uint PWMB = 9, BIN1 = 3, BIN2 = 2;\nconst uint TRIG = 11, ECHO = 12;\n\nconst float DISTANCIA_STOP = 15.0f;\n\nvoid init_hardware() {\n    stdio_init_all();\n\n    gpio_init(STBY); gpio_set_dir(STBY, GPIO_OUT); gpio_put(STBY, 1);\n\n    gpio_init(AIN1); gpio_set_dir(AIN1, GPIO_OUT);\n    gpio_init(AIN2); gpio_set_dir(AIN2, GPIO_OUT);\n    gpio_init(BIN1); gpio_set_dir(BIN1, GPIO_OUT);\n    gpio_init(BIN2); gpio_set_dir(BIN2, GPIO_OUT);\n\n    gpio_set_function(PWMA, GPIO_FUNC_PWM);\n    gpio_set_function(PWMB, GPIO_FUNC_PWM);\n\n    uint sliceA = pwm_gpio_to_slice_num(PWMA);\n    uint sliceB = pwm_gpio_to_slice_num(PWMB);\n\n    pwm_set_wrap(sliceA, 65535); pwm_set_enabled(sliceA, true);\n    pwm_set_wrap(sliceB, 65535); pwm_set_enabled(sliceB, true);\n\n    gpio_init(TRIG); gpio_set_dir(TRIG, GPIO_OUT); gpio_put(TRIG, 0);\n    gpio_init(ECHO); gpio_set_dir(ECHO, GPIO_IN);\n}\n\nvoid mover(bool avanzar) {\n    uint16_t velocidad = 60000;\n\n    if (avanzar) {\n        gpio_put(AIN1, 0); \n        gpio_put(AIN2, 1);\n        gpio_put(BIN1, 0); \n        gpio_put(BIN2, 1);\n        pwm_set_gpio_level(PWMA, velocidad);\n        pwm_set_gpio_level(PWMB, velocidad);\n    } else {\n        gpio_put(AIN1, 0); gpio_put(AIN2, 0);\n        gpio_put(BIN1, 0); gpio_put(BIN2, 0);\n        pwm_set_gpio_level(PWMA, 0);\n        pwm_set_gpio_level(PWMB, 0);\n    }\n}\n\nfloat leer_distancia() {\n    gpio_put(TRIG, 1); sleep_us(10); gpio_put(TRIG, 0);\n\n    absolute_time_t timeout = make_timeout_time_ms(30);\n\n    while(gpio_get(ECHO) == 0) {\n        if(absolute_time_diff_us(get_absolute_time(), timeout) &lt; 0) return 0.0;\n    }\n    absolute_time_t start = get_absolute_time();\n\n    while(gpio_get(ECHO) == 1) {\n        if(absolute_time_diff_us(get_absolute_time(), timeout) &lt; 0) return 0.0;\n    }\n    absolute_time_t end = get_absolute_time();\n\n    return (float)absolute_time_diff_us(start, end) / 58.0f;\n}\n\nint main() {\n    init_hardware();\n    sleep_ms(3000);\n\n    printf(\"--- INICIANDO TEST (DIRECCION CORREGIDA) ---\\n\");\n\n    while (true) {\n        float distancia = leer_distancia();\n\n        if (distancia &gt; 0.1) {\n            printf(\"Distancia: %.1f cm\\n\", distancia);\n\n            if (distancia &lt; DISTANCIA_STOP) {\n                mover(false);\n            } else {\n                mover(true);\n            }\n        }\n        sleep_ms(50);\n    }\n}\n</code></pre></p> </li> <li> <p>Prueba de sensores <pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/timer.h\"\n\nclass Sensor {\nprivate:\n    uint _trig, _echo;\npublic:\n    Sensor(uint trig, uint echo) : _trig(trig), _echo(echo) {\n        gpio_init(_trig); gpio_set_dir(_trig, GPIO_OUT); gpio_put(_trig, 0);\n        gpio_init(_echo); gpio_set_dir(_echo, GPIO_IN);\n    }\n\n    float leer() {\n        gpio_put(_trig, 0); sleep_us(2);\n        gpio_put(_trig, 1); sleep_us(10);\n        gpio_put(_trig, 0);\n\n        absolute_time_t timeout = make_timeout_time_ms(30);\n\n        while (gpio_get(_echo) == 0) {\n            if (absolute_time_diff_us(get_absolute_time(), timeout) &lt; 0) return -1.0;\n        }\n        absolute_time_t start = get_absolute_time();\n\n        while (gpio_get(_echo) == 1) {\n            if (absolute_time_diff_us(get_absolute_time(), timeout) &lt; 0) return -1.0;\n        }\n        absolute_time_t end = get_absolute_time();\n\n        return (float)absolute_time_diff_us(start, end) / 58.0f;\n    }\n};\n\nSensor izq(15, 18);\nSensor frente(11, 12);\nSensor der(26, 27);\n\nint main() {\n    stdio_init_all();\n    sleep_ms(3000);\n    printf(\"\\n--- INICIANDO TEST DE 3 SENSORES ---\\n\");\n\n    while (true) {\n        float dI = izq.leer();\n        sleep_ms(5);\n        float dF = frente.leer();\n        sleep_ms(5);\n        float dD = der.leer();\n        sleep_ms(5);\n\n        printf(\"IZQ: %5.1f cm  |  FRENTE: %5.1f cm  |  DER: %5.1f cm\\n\", dI, dF, dD);\n\n        sleep_ms(500);\n    }\n    return 0;\n}\n</code></pre></p> </li> </ul> <p>3) Esquematico de conexion: </p> <p>4) Evidencias</p> <p>Pruerba de sensores de proximidad </p> <p>Prueba de motores <p>5) Otras Pruebas</p> <ul> <li> <p>Prueba de PIO (Programmable I/O) Se verific\u00f3 que los perif\u00e9ricos controlados por PIO para la lectura de encoders y generaci\u00f3n de se\u00f1ales PWM funcionaran sin bloquear la CPU. Se midi\u00f3 que las rutinas en PIO mantuvieran el mismo periodo y no perdieran pulsos del encoder.</p> </li> <li> <p>Prueba de DMA Se us\u00f3 DMA para mover datos. La prueba consisti\u00f3 en confirmar que las transferencias no perdieran datos y que la CPU permaneciera libre durante la operaci\u00f3n.</p> </li> <li> <p>Prueba de UART Se prob\u00f3 el enlace UART para configurar y monitorear al robot. La prueba consisti\u00f3 en enviar comandos y verificar que no hubiera errores de transmisi\u00f3n ni desbordes en los buffers.</p> </li> <li> <p>Prueba de WDT Se activ\u00f3 el watchdog para reiniciar la MCU en caso de bloqueo del programa. La prueba consisti\u00f3 en \u201ccongelar\u201d intencionalmente el c\u00f3digo para verificar que el WDT hiciera el reinicio de forma segura.</p> </li> <li> <p>Prueba de Energ\u00eda Se midi\u00f3 el voltaje de las l\u00edneas de 7.4V, 5V y 3.3V durante carga de motores. La prueba verific\u00f3 que los reguladores mantuvieran el voltaje estable sin ca\u00eddas peligrosas.</p> </li> <li> <p>Prueba de EMC Se revis\u00f3 que el ruido de los motores y del puente H no afectara los sensores ni la Raspberry Pi Pico.</p> </li> </ul>"},{"location":"Sistemas%20embebidos%20l/Micromouse/#fase-2-ensamblado","title":"Fase 2 - Ensamblado","text":"<p>1) Descripci\u00f3n breve: Una vez probado el circuito y componentes sigue el dise\u00f1o y fabricai\u00f3n de la PCB en Altium Designer y su soldado de componentes e impresi\u00f3n de piezas en 3D.</p> <p>2) PCB: </p> <p>3) Dise\u00f1o de piezas 3D </p>"},{"location":"Sistemas%20embebidos%20l/Micromouse/#fase-3-final","title":"Fase 3 - Final","text":"<p>1) Descripci\u00f3n breve: Ya que tenemos nuestro micromouse probado y ensamblado ahora queda programarlo para que recorra el laberinto por si solo.</p> <p>2) Codigo:</p> <pre><code>:(\n</code></pre> <p>3) Esquematico de conexion: </p> <p>4) Video:</p> <p>:(</p>"},{"location":"Sistemas%20embebidos%20l/Micromouse/#aprendizajes","title":"Aprendizajes:","text":"<ul> <li> <p>Consideraci\u00f3n de tiempos: Mejorar la optimizaci\u00f3n de tiempos considerados y usados, fortalecer el trabajo en equipo para ciertas etapas del micromouse puesto que por el tiempo era algo reducido</p> </li> <li> <p>Tiempos de ejecuci\u00f3n: Medir el tiempo que tardan las funciones (sensado, control, motores) ayuda a saber si el robot puede reaccionar lo suficientemente r\u00e1pido dentro del laberinto. Si una tarea tarda demasiado, el robot se vuelve lento o impreciso.</p> </li> <li> <p>Jitter: El jitter es la variaci\u00f3n del tiempo entre cada ciclo de control. Si el jitter es alto, los motores reciben comandos irregulares y el robot avanza con \u201cmicro sacudidas\u201d.</p> </li> <li> <p>P\u00e9rdidas FIFO/DMA: Cuando no se vacian a tiempo el FIFO o no se configura bien el DMA, se pierden datos. Esto afecta sensores y telemetr\u00eda. Ajustar prioridades y tama\u00f1os de buffer evita esas p\u00e9rdidas.</p> </li> <li> <p>Consumo de energ\u00eda: Medir el consumo permiti\u00f3 saber cu\u00e1nto duran realmente los motores, sensores y la MCU con la bater\u00eda. As\u00ed se confirm\u00f3 que el regulador y la bater\u00eda deber\u00edan ser suficientes para terminar el recorrido sin apagarse.</p> </li> </ul>"},{"location":"Sistemas%20embebidos%20l/Tarea%201/","title":"\ud83d\udcda Tarea 1","text":""},{"location":"Sistemas%20embebidos%20l/Tarea%201/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Tabla comparativa de microcontroladores </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 25/08/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra un cuadro comparativo sobre microcontroladores elegidos por mi, mencionando cuales me parecen mejores, cuales usar\u00eda y porque.</li> </ul> <p>1) Cuadro comparativo</p> <p></p> <p>Elej\u00ed estos microcontroladores porque conozco a algunos y porque quise variar sus caracteristicas para compararlos mejor y no con uno muy similar.</p> <p>En mi opini\u00f3n me gusta mas el ESP32 por sus perifericos, en segundo lugar pondria al ATmega328P por su uso en arduino ya conocido, en tercero seria RP2040 por la IA pero espero conocerlo m\u00e1s con posibilidad de subirlo de nviel, en cuarto dejo ap TI MSP430 porque no eh tenido la oportunidad de usarlo.</p> <p>Para mi proyecto usaria este orden RP2040, ESP32, ATmega328P y al ultimo igualmente el TI MSP430.</p>"},{"location":"Sistemas%20embebidos%20l/Tarea%202/","title":"\ud83d\udcda Tarea 2","text":""},{"location":"Sistemas%20embebidos%20l/Tarea%202/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Outputs Basicos </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 27/08/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestran 3 ejercicios un Contador binario 4 bits, un barrido de 5 leds y una secuencia en codigo Gray.</li> </ul>"},{"location":"Sistemas%20embebidos%20l/Tarea%202/#contador-binario-de-4-bits","title":"Contador binario de 4 bits","text":"<p>1) Que debe hacer: En cuatro leds debe mostrarse cad segundo la representacion binaria del 0 al 15</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#define A   0\n#define B   1\n#define C   2\n#define D   3\n\nint main() {\n   const uint32_t MASK = (1u&lt;&lt;A) | (1u&lt;&lt;B) | (1u&lt;&lt;C) | (1u&lt;&lt;D);\n   gpio_init_mask(MASK);\n   gpio_set_dir_masked(MASK, MASK);  \n   while (true) {\n       for (uint8_t i = 0; i &lt; 16; i++) {\n           gpio_put_masked(MASK, i &lt;&lt; A);\n           sleep_ms(500);                \n       }\n   }\n}\n</code></pre></p> <p>3) Esquematico de conexi\u00f3n: </p> <p>4) Video:</p>"},{"location":"Sistemas%20embebidos%20l/Tarea%202/#barrido-de-5-leds","title":"Barrido de 5 Leds","text":"<p>1) Que debe hacer: Correr un \u201c1\u201d por cinco LEDs P0..P3 y regresar (0\u21921\u21922\u21923\u21922\u21921\u2026)</p> <p>2) Codigo: <pre><code>#include \"pico/stdli-b.h\"\n#include \"hardware/gpio.h\"\n#define A 0  \n#define B 1  \n#define C 2  \n#define D 3\n#define E 4  \nint main() {\n   const uint32_t MASK = (1u&lt;&lt;A) | (1u&lt;&lt;B) | (1u&lt;&lt;C) | (1u&lt;&lt;D) | (1u&lt;&lt;E);\n   gpio_init_mask(MASK);\n   gpio_set_dir_out_masked(MASK);  \n   gpio_clr_mask(MASK);            \n   while (true) {\n       for (int i = 0; i &lt; 5; ++i) {\n           gpio_clr_mask(MASK);                \n           gpio_set_mask(1 &lt;&lt; i);              \n           sleep_ms(300);\n       }\n       for (int i = 3; i &gt; 0; --i) {\n           gpio_clr_mask(MASK);\n           gpio_set_mask(1 &lt;&lt; i);\n           sleep_ms(300);\n       }\n   }\n}\n</code></pre></p> <p>3) Esquematico de conexi\u00f3n: </p> <p>4) Video: </p>"},{"location":"Sistemas%20embebidos%20l/Tarea%202/#secuencia-en-codigo-gray","title":"Secuencia en codigo Gray","text":"<p>1) Que debe hacer: En cuatro leds debe mostrarse cad segundo la representacion en codigo Gray del 0 al 15</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#define A 0\n#define B 1\n#define C 2\nuint8_t bin_gray(uint8_t num_dec) {\n   return num_dec ^ (num_dec &gt;&gt; 1);\n}\nint main() {\n   const uint8_t MASK = (1u &lt;&lt; A) | (1u &lt;&lt; B) | (1u &lt;&lt; C);\n   gpio_init_mask(MASK);\n   gpio_set_dir_masked(MASK, MASK);\n   while (true) {\n       for (uint8_t i = 0; i &lt; 8; i++) {\n           uint8_t gray = bin_gray(i);\n           gpio_put_masked(MASK, gray);\n           sleep_ms(500);\n       }\n   }\n}\n</code></pre></p> <p>3) Esquematico de conexi\u00f3n: </p> <p>4) Video:</p>"},{"location":"Sistemas%20embebidos%20l/Tarea%203/","title":"\ud83d\udcda Tarea 3","text":""},{"location":"Sistemas%20embebidos%20l/Tarea%203/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Inputs </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 01/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestran  2 ejercicios 3 compuertas b\u00e1sicas AND / OR / XOR con 2 botones y un selector c\u00edclico de 4 LEDs con avance/retroceso.</li> </ul>"},{"location":"Sistemas%20embebidos%20l/Tarea%203/#3-compuertas-basicas-and-or-xor-con-2-botones","title":"3 compuertas b\u00e1sicas AND / OR / XOR con 2 botones","text":"<p>1) Que debe hacer: Con dos botones A y B (pull-up; presionado=0) enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. En el video muestra las 4 combinaciones (00, 01, 10, 11).</p> <p>2) Codigo: Codigo de compuerta AND <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define BTN_A 0\n#define BTN_B 1\n#define LED_AND 2\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(BTN_A);\n    gpio_set_dir(BTN_A, false);\n    gpio_pull_up(BTN_A);\n\n    gpio_init(BTN_B);\n    gpio_set_dir(BTN_B, false);\n    gpio_pull_up(BTN_B);\n\n    gpio_init(LED_AND);\n    gpio_set_dir(LED_AND, true);\n\n    while (true) {\n        bool a = !gpio_get(BTN_A);\n        bool b = !gpio_get(BTN_B);\n\n        bool result = a &amp;&amp; b;\n\n        gpio_put(LED_AND, result);\n\n        sleep_ms(50);\n    }\n}\n</code></pre></p> <p>Codigo: Codigo de compuerta OR <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define BTN_A 0\n#define BTN_B 1\n#define LED_OR 2\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(BTN_A); gpio_set_dir(BTN_A, false); gpio_pull_up(BTN_A);\n    gpio_init(BTN_B); gpio_set_dir(BTN_B, false); gpio_pull_up(BTN_B);\n\n    gpio_init(LED_OR); gpio_set_dir(LED_OR, true);\n\n    while (true) {\n        bool a = !gpio_get(BTN_A);\n        bool b = !gpio_get(BTN_B);\n\n        bool result = a || b;\n\n        gpio_put(LED_OR, result);\n        sleep_ms(50);\n    }\n}\n</code></pre> Codigo: Codigo de compuerta XOR <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define BTN_A 0\n#define BTN_B 1\n#define LED_XOR 2\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(BTN_A); gpio_set_dir(BTN_A, false); gpio_pull_up(BTN_A);\n    gpio_init(BTN_B); gpio_set_dir(BTN_B, false); gpio_pull_up(BTN_B);\n\n    gpio_init(LED_XOR); gpio_set_dir(LED_XOR, true);\n\n    while (true) {\n        bool a = !gpio_get(BTN_A);\n        bool b = !gpio_get(BTN_B);\n\n        bool result = a ^ b;\n\n        gpio_put(LED_XOR, result);\n        sleep_ms(50);\n    }\n}\n</code></pre> 3) Esquematico de conexion: Se us\u00f3 el mismo circuito para las 3 compuertas </p> <p>4) Video:</p> <p>Compuerta AND</p> <p>Compuerta OR</p> <p>Compuerta XOR</p>"},{"location":"Sistemas%20embebidos%20l/Tarea%203/#selector-ciclico-de-4-leds-con-avanceretroceso","title":"Selector c\u00edclico de 4 LEDs con avance/retroceso","text":"<p>1) Que debe hacer: Mant\u00e9n un \u00fanico LED encendido entre LED0..LED3. Un bot\u00f3n AVANZA (0\u21921\u21922\u21923\u21920) y otro RETROCEDE (0\u21923\u21922\u21921\u21920). Un push = un paso (antirrebote por flanco: si dejas presionado no repite). En el video demuestra en ambos sentidos.</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n\n#define BTN_PREV 0      \n#define BTN_NEXT 1    \n#define LED0   2\n#define LED1   3\n#define LED2   4\n#define LED3   5\n\nuint8_t STATE = LED0 - 1;\n\nint main(void) {\n    const uint8_t LEDs_M = (1u &lt;&lt; LED0 | 1u &lt;&lt; LED1 | 1u &lt;&lt; LED2 | 1u &lt;&lt; LED3);\n\n    gpio_init_mask(LEDs_M);\n    gpio_set_dir_out_masked(LEDs_M);\n    gpio_set_mask(LEDs_M);   \n    gpio_clr_mask(LEDs_M);\n\n    gpio_init(BTN_PREV);\n    gpio_set_dir(BTN_PREV, GPIO_IN);\n    gpio_pull_up(BTN_PREV);\n\n    gpio_init(BTN_NEXT);\n    gpio_set_dir(BTN_NEXT, GPIO_IN);\n    gpio_pull_up(BTN_NEXT);\n\n    bool NEXT_PREVSTATE = 1;\n    bool PREV_PREVSTATE = 1;\n\n    while (true) {\n        bool NEXT_STATE = !gpio_get(BTN_NEXT);\n        bool PREV_STATE = !gpio_get(BTN_PREV);\n\n        if (NEXT_STATE &amp;&amp; !NEXT_PREVSTATE) {\n            if (STATE == LED3) {\n                STATE = LED0;\n            } else {\n                STATE ++;\n            }\n            gpio_clr_mask(LEDs_M);                \n            gpio_set_mask(1 &lt;&lt; STATE);              \n        }\n\n        if (PREV_STATE &amp;&amp; !PREV_PREVSTATE) {\n            if (STATE == LED0) {\n                STATE = LED3;\n            } else {\n                STATE --;\n            }\n            gpio_clr_mask(LEDs_M);                \n            gpio_set_mask(1 &lt;&lt; STATE);              \n        }\n\n        NEXT_PREVSTATE = NEXT_STATE;\n        PREV_PREVSTATE = PREV_STATE;\n\n        sleep_ms(10);\n    }\n}\n</code></pre></p> <p>3) Esquematico de conexion: </p> <p>4) Video:</p>"},{"location":"Sistemas%20embebidos%20l/Tarea%204/","title":"\ud83d\udcda Tarea 4","text":""},{"location":"Sistemas%20embebidos%20l/Tarea%204/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Led Pong </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 04/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestra el juego \"Led Pong\" hecho con una raspberry Pico 2.</li> </ul>"},{"location":"Sistemas%20embebidos%20l/Tarea%204/#led-pong","title":"LED PONG","text":"<p>1) Que debe hacer: Se trara de un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado.</p> <p>2) Reglas del juego</p> <p>1) Pelota: es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro (L1\u2192L5\u2192L1\u2026) a un ritmo fijo.</p> <p>2) Golpe con ISR: cada bot\u00f3n genera una interrupci\u00f3n.</p> <ul> <li> <p>El BTN_L solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L1.</p> </li> <li> <p>El BTN_R solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L5.</p> </li> <li> <p>Si coincide, la pelota rebota: invierte su direcci\u00f3n.</p> </li> <li> <p>Si no coincide (la pelota no est\u00e1 en el \u00faltimo LED de ese lado), el bot\u00f3n se ignora.</p> </li> </ul> <p>3) Fallo y punto: si la pelota alcanza L1 y no hubo golpe v\u00e1lido del lado izquierdo en ese momento, anota el jugador derecho. An\u00e1logamente, si alcanza L5 sin golpe v\u00e1lido, anota el jugador izquierdo.</p> <p>4) Indicador de punto: al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto .</p> <p>5) Reinicio tras punto: despu\u00e9s del parpadeo, la pelota se reinicia en el centro (L3) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> <p>6) Inicio del juego: al encender, la pelota inicia en L3 y no se mueve hasta que se presione un boton y debera moverse a la direccion opuesta del boton presionado.</p> <p>3) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define LED_P1 0\n#define L1     1\n#define L2     2\n#define L3     3\n#define L4     4\n#define L5     5\n#define LED_P2 6\n\n#define BTN_L  7\n#define BTN_R  8\n\nvolatile bool golpe_L = false;\nvolatile bool golpe_R = false;\nint pos = L3;\nint dir = 0;\n\nvoid boton_isr(uint gpio, uint32_t events) {\n    if (gpio == BTN_L) {\n        if (pos == L1) golpe_L = true;\n        else if (dir == 0) dir = 1;\n    }\n    else if (gpio == BTN_R) {\n        if (pos == L5) golpe_R = true;\n        else if (dir == 0) dir = -1;\n    }\n}\n\nvoid parpadear_led(int led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(200);\n        gpio_put(led, 0);\n        sleep_ms(200);\n    }\n}\n\nvoid reiniciar_juego(int ganador) {\n    parpadear_led(ganador);\n    pos = L3;\n    gpio_put(L3, 1);\n\n    if (ganador == LED_P2) {\n        dir = 1;\n    } else if (ganador == LED_P1) {\n        dir = -1;\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    const uint32_t MASK = (1u&lt;&lt;LED_P1)|(1u&lt;&lt;L1)|(1u&lt;&lt;L2)|(1u&lt;&lt;L3)|(1u&lt;&lt;L4)|(1u&lt;&lt;L5)|(1u&lt;&lt;LED_P2);\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);\n\n    gpio_init(BTN_L); gpio_set_dir(BTN_L, false); gpio_pull_up(BTN_L);\n    gpio_init(BTN_R); gpio_set_dir(BTN_R, false); gpio_pull_up(BTN_R);\n\n    gpio_set_irq_enabled_with_callback(BTN_L, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n    gpio_set_irq_enabled(BTN_R, GPIO_IRQ_EDGE_FALL, true);\n\n    int pos_anterior = L3;\n    gpio_put(pos_anterior, 1);\n\n    while (true) {\n\n        gpio_put(pos_anterior, 0);\n        gpio_put(pos, 1);\n        pos_anterior = pos;\n\n        sleep_ms(500);\n\n        if (dir == 0) continue;\n\n        if (pos == L1) {\n            if (golpe_L) {\n                dir = 1;\n                golpe_L = false;\n            } else {\n                reiniciar_juego(LED_P2);\n                continue;\n            }\n        } else if (pos == L5) {\n            if (golpe_R) {\n                dir = -1;\n                golpe_R = false;\n            } else {\n                reiniciar_juego(LED_P1);\n                continue;\n            }\n        }\n\n        if (pos == L2 &amp;&amp; golpe_L) {\n            dir = 1;\n            golpe_L = false;\n        } else if (pos == L4 &amp;&amp; golpe_R) {\n            dir = -1;\n            golpe_R = false;\n        }\n\n        pos += dir;\n    }\n}\n</code></pre></p> <p>4) Esquematico de conexion: </p> <p>5) Video:</p>"},{"location":"Sistemas%20embebidos%20l/Tarea%205/","title":"\ud83d\udcda Tarea 5","text":""},{"location":"Sistemas%20embebidos%20l/Tarea%205/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Ejercicios de medicion </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 15/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestran 2 ejercicios de medici\u00f3n con osciloscopio.</li> </ul>"},{"location":"Sistemas%20embebidos%20l/Tarea%205/#ejercicio-1-medicion-en-osciloscopio-del-periodo-y-jitter-usando-alarm0-modo-s","title":"(Ejercicio 1) Medici\u00f3n en osciloscopio del periodo y jitter usando ALARM0 (modo \u00b5s)","text":"<p>1) Que debe hacer: Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio: - Periodo promedio y tolerancia. - Jitter pico-a-pico y, si tu equipo lo permite, RMS. - Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s)..</p> <p>2) Codigo: <pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       0\n#define ALARM_NUM     1  // usaremos la alarma 1\n\n// Calcula el n\u00famero de IRQ para esa alarma\n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 100000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre> 3) Parametros</p> <ul> <li> <p>2 Volts</p> </li> <li> <p>Zoom factor 2x</p> </li> <li> <p>Cursores \u25b3t = 0.003s</p> </li> </ul> <p>4) Esquematico de conexion: </p> <p>5) Muestras de la medic\u00f3n </p>"},{"location":"Sistemas%20embebidos%20l/Tarea%205/#ejercicio-2-comparar-jitterprecision-con-osciloscopio-modo-s-vs-modo-ciclos","title":"(Ejercicio 2) Comparar jitter/precisi\u00f3n con osciloscopio: modo \u00b5s vs modo ciclos","text":"<p>1) Que debe hacer: _Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> <ul> <li>Usa rearme acumulativo.</li> <li>Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico. Con el osciloscopio, mide y registra para cada modo:</li> <li>Periodo promedio y desviaci\u00f3n respecto al nominal.</li> <li>Jitter pico-a-pico y/o RMS.</li> <li>Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.(mantener modo \u00b5s).._</li> </ul> <p>2) Codigo: <pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       0\n#define ALARM_NUM     1  // usaremos la alarma 1\n\n// Calcula el n\u00famero de IRQ para esa alarma\n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 100000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre></p> <p>3) Parametros</p> <ul> <li> <p>2 Volts</p> </li> <li> <p>Zoom factor 2x</p> </li> <li> <p>Cursores \u25b3t = 0.003s</p> </li> </ul> <p>4) Esquematico de conexion: </p> <p>5) Muestras de la medic\u00f3n </p>"},{"location":"Sistemas%20embebidos%20l/Tarea%206/","title":"\ud83d\udcda Tarea 6","text":""},{"location":"Sistemas%20embebidos%20l/Tarea%206/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Ejercicios de medicion </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 17/09/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestran 2 ejercicios el uso de 4 alarmas con leds y una actualizaci\u00f3n del juego \"Led Pong\".</li> </ul>"},{"location":"Sistemas%20embebidos%20l/Tarea%206/#timer","title":"Timer","text":"<p>1) Que debe hacer: Configurar ALARM0..ALARM3 del timer de sistema en modo \u00b5s. Cada alarma controla un LED distinto con un periodo propio.</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#include \"pico/time.h\"\n\n#define LED_A 0\n#define LED_B 1\n#define LED_C 2\n#define LED_D 3\n\nstatic const uint8_t leds[] = { LED_A, LED_B, LED_C, LED_D };\n\nstatic const uint32_t periodos_us[] = {\n    300000u,\n    200000u,\n    120000u,\n     80000u\n};\n\nstatic uint32_t proximo_cambio[4];\n\nint main() {\n\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(leds[i]);\n        gpio_set_dir(leds[i], true);\n        gpio_put(leds[i], false);\n    }\n\n    uint32_t t_actual = time_us_32();\n    for (int i = 0; i &lt; 4; i++) {\n        proximo_cambio[i] = t_actual + periodos_us[i];\n    }\n\n    while (true) {\n        t_actual = time_us_32();\n        for (int i = 0; i &lt; 4; i++) {\n            if ((int32_t)(t_actual - proximo_cambio[i]) &gt;= 0) {\n                gpio_xor_mask(1u &lt;&lt; leds[i]);\n                proximo_cambio[i] += periodos_us[i];\n            }\n        }\n        tight_loop_contents();\n    }\n}\n</code></pre></p> <p>3) Esquematico de conexion: </p> <p>4) Video:</p>"},{"location":"Sistemas%20embebidos%20l/Tarea%206/#led-pong-20","title":"Led Pong 2.0","text":"<p>1) Que debe hacer: Modificar el \"Led pong\", para tener dos botones adicionales, que suban y bajen la velocidad del juego sin delay.</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define LED_P1 0\n#define L1     1\n#define L2     2\n#define L3     3\n#define L4     4\n#define L5     5\n#define LED_P2 6\n\n#define BTN_L  7\n#define BTN_R  8\n#define BTN_UP 9    //subir velocidad\n#define BTN_DOWN 10 //bajar velocidad\n\nvolatile bool golpe_L = false;\nvolatile bool golpe_R = false;\nint pos = L3;\nint dir = 0;\n\n//velocidad de juego en ms\nvolatile uint32_t velocidad = 500;  \nconst uint32_t VEL_MIN = 100;\nconst uint32_t VEL_MAX = 1000;\nconst uint32_t VEL_PASO = 50;\n\nvoid boton_isr(uint gpio, uint32_t events) {\n    if (gpio == BTN_L) {\n        if (pos == L1) golpe_L = true;\n        else if (dir == 0) dir = 1;\n    }\n    else if (gpio == BTN_R) {\n        if (pos == L5) golpe_R = true;\n        else if (dir == 0) dir = -1;\n    }\n    else if (gpio == BTN_UP) {\n        if (velocidad &gt; VEL_MIN + VEL_PASO) velocidad -= VEL_PASO;\n        else velocidad = VEL_MIN;\n    }\n    else if (gpio == BTN_DOWN) {\n        if (velocidad &lt; VEL_MAX - VEL_PASO) velocidad += VEL_PASO;\n        else velocidad = VEL_MAX;\n    }\n}\n\nvoid parpadear_led(int led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(200);\n        gpio_put(led, 0);\n        sleep_ms(200);\n    }\n}\n\nvoid reiniciar_juego(int ganador) {\n    parpadear_led(ganador);\n    pos = L3;\n    gpio_put(L3, 1);\n\n    if (ganador == LED_P2) {\n        dir = 1;\n    } else if (ganador == LED_P1) {\n        dir = -1;\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    const uint32_t MASK = (1u&lt;&lt;LED_P1)|(1u&lt;&lt;L1)|(1u&lt;&lt;L2)|(1u&lt;&lt;L3)|(1u&lt;&lt;L4)|(1u&lt;&lt;L5)|(1u&lt;&lt;LED_P2);\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);\n\n    gpio_init(BTN_L); gpio_set_dir(BTN_L, false); gpio_pull_up(BTN_L);\n    gpio_init(BTN_R); gpio_set_dir(BTN_R, false); gpio_pull_up(BTN_R);\n    gpio_init(BTN_UP); gpio_set_dir(BTN_UP, false); gpio_pull_up(BTN_UP);\n    gpio_init(BTN_DOWN); gpio_set_dir(BTN_DOWN, false); gpio_pull_up(BTN_DOWN);\n\n    gpio_set_irq_enabled_with_callback(BTN_L, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n    gpio_set_irq_enabled(BTN_R, GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(BTN_UP, GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(BTN_DOWN, GPIO_IRQ_EDGE_FALL, true);\n\n    int pos_anterior = L3;\n    gpio_put(pos_anterior, 1);\n\n    while (true) {\n\n        gpio_put(pos_anterior, 0);\n        gpio_put(pos, 1);\n        pos_anterior = pos;\n\n        sleep_ms(velocidad); //controlable con botones\n\n        if (dir == 0) continue;\n\n        if (pos == L1) {\n            if (golpe_L) {\n                dir = 1;\n                golpe_L = false;\n            } else {\n                reiniciar_juego(LED_P2);\n                continue;\n            }\n        } else if (pos == L5) {\n            if (golpe_R) {\n                dir = -1;\n                golpe_R = false;\n            } else {\n                reiniciar_juego(LED_P1);\n                continue;\n            }\n        }\n\n        if (pos == L2 &amp;&amp; golpe_L) {\n            dir = 1;\n            golpe_L = false;\n        } else if (pos == L4 &amp;&amp; golpe_R) {\n            dir = -1;\n            golpe_R = false;\n        }\n\n        pos += dir;\n    }\n}\n</code></pre></p> <p>3) Esquematico de conexion: </p> <p>4) Video:</p>"},{"location":"Sistemas%20embebidos%20l/Tarea%207/","title":"\ud83d\udcda Tarea 7","text":""},{"location":"Sistemas%20embebidos%20l/Tarea%207/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: Ejercicios de medicion </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 01/10/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestran 3 ejercicios Control de Duty Cycle \u2014 Motor DC, Control de Frecuencia \u2014 Canci\u00f3n con Buzzer y Generaci\u00f3n de Se\u00f1ales \u2014 Senoidal de 60 Hz con PWM + Filtro RC.</li> </ul>"},{"location":"Sistemas%20embebidos%20l/Tarea%207/#control-de-duty-cycle-motor-dc","title":"Control de Duty Cycle \u2014 Motor DC","text":"<p>1) Que debe hacer:</p> <p>Implementar un circuito con un motor DC controlado mediante PWM variando el duty cycle.</p> <p>Usar 2 botones para seleccionar entre 3 velocidades predefinidas (baja, media y alta).</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;stdio.h&gt;\n\n#define PIN_PWM       0\n#define PIN_AIN1      1\n#define PIN_AIN2      2\n#define PIN_STBY      3\n#define PIN_BTN_UP    4\n#define PIN_BTN_DOWN  5\n\n#define PWM_TOP       625u\n#define PWM_CLKDIV_VAL 10.0f\n\n#define PCT_LOW   30.0f\n#define PCT_MED   60.0f\n#define PCT_HIGH  90.0f\n\n#define DEBOUNCE_TIME_MS 50\n\nstatic uint pwm_slice = 0;\nstatic uint pwm_chan  = 0;\nstatic uint32_t duty_table[3];\n\nstatic void setup_pwm_pin(uint gpio_pin) {\n    gpio_set_function(gpio_pin, GPIO_FUNC_PWM);\n    pwm_slice = pwm_gpio_to_slice_num(gpio_pin);\n    pwm_chan  = pwm_gpio_to_channel(gpio_pin);\n    pwm_set_wrap(pwm_slice, PWM_TOP);\n    pwm_set_clkdiv(pwm_slice, PWM_CLKDIV_VAL);\n    pwm_set_chan_level(pwm_slice, pwm_chan, 0);\n    pwm_set_enabled(pwm_slice, true);\n}\n\nstatic bool is_button_single_press(uint gpio_pin) {\n    static absolute_time_t last_up = (absolute_time_t){0};\n    static absolute_time_t last_down = (absolute_time_t){0};\n    absolute_time_t *last = (gpio_pin == PIN_BTN_UP) ? &amp;last_up : &amp;last_down;\n\n    if (gpio_get(gpio_pin) == 0) {\n        absolute_time_t now = get_absolute_time();\n        if (absolute_time_diff_us(*last, now) &lt; (DEBOUNCE_TIME_MS * 1000)) {\n            return false;\n        }\n        sleep_ms(10);\n        if (gpio_get(gpio_pin) == 0) {\n            *last = now;\n            while (gpio_get(gpio_pin) == 0) sleep_ms(5);\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(PIN_AIN1); gpio_set_dir(PIN_AIN1, GPIO_OUT);\n    gpio_init(PIN_AIN2); gpio_set_dir(PIN_AIN2, GPIO_OUT);\n    gpio_init(PIN_STBY); gpio_set_dir(PIN_STBY, GPIO_OUT);\n\n    gpio_init(PIN_BTN_UP);   gpio_set_dir(PIN_BTN_UP, GPIO_IN);   gpio_pull_up(PIN_BTN_UP);\n    gpio_init(PIN_BTN_DOWN); gpio_set_dir(PIN_BTN_DOWN, GPIO_IN); gpio_pull_up(PIN_BTN_DOWN);\n\n    setup_pwm_pin(PIN_PWM);\n\n    duty_table[0] = (uint32_t)((PCT_LOW  / 100.0f) * (float)(PWM_TOP + 1));\n    duty_table[1] = (uint32_t)((PCT_MED  / 100.0f) * (float)(PWM_TOP + 1));\n    duty_table[2] = (uint32_t)((PCT_HIGH / 100.0f) * (float)(PWM_TOP + 1));\n\n    int idx_speed = 0;\n\n    gpio_put(PIN_AIN1, 1);\n    gpio_put(PIN_AIN2, 0);\n\n    gpio_put(PIN_STBY, 1);\n\n    pwm_set_chan_level(pwm_slice, pwm_chan, duty_table[idx_speed]);\n\n    printf(\"Motor control arrancado. PWM pin: %d\\n\", PIN_PWM);\n\n    while (true) {\n        if (is_button_single_press(PIN_BTN_UP)) {\n            idx_speed = (idx_speed + 1) % 3;\n            pwm_set_chan_level(pwm_slice, pwm_chan, duty_table[idx_speed]);\n            printf(\"Velocidad -&gt; %d (level=%u)\\n\", idx_speed, (unsigned)duty_table[idx_speed]);\n        }\n        if (is_button_single_press(PIN_BTN_DOWN)) {\n            idx_speed = (idx_speed + 2) % 3;\n            pwm_set_chan_level(pwm_slice, pwm_chan, duty_table[idx_speed]);\n            printf(\"Velocidad -&gt; %d (level=%u)\\n\", idx_speed, (unsigned)duty_table[idx_speed]);\n        }\n        sleep_ms(20);\n    }\n\n    return 0;\n}\n</code></pre> 3) Explicaci\u00f3n de la frecuencia de corte:</p> <p>El filtro RC se dise\u00f1a para dejar pasar se\u00f1ales de 60 Hz y eliminar las componentes de alta frecuencia que provienen del PWM.</p> <p>La frecuencia de corte (fcf_cfc\u200b) es el punto donde el filtro empieza a atenuar las se\u00f1ales. Matem\u00e1ticamente:</p> <p>\u200b En este caso, queremos que fc sea un poco mayor que 60 Hz para que nuestra se\u00f1al sinusoidal de 60 Hz no sea atenuada.</p> <p>4) Esquematico de conexion: </p> <p>5) Video:</p>"},{"location":"Sistemas%20embebidos%20l/Tarea%207/#control-de-frecuencia-cancion-con-buzzer","title":"Control de Frecuencia \u2014 Canci\u00f3n con Buzzer","text":"<p>1) Que debe hacer:</p> <p>Programar un buzzer piezoel\u00e9ctrico para reproducir una melod\u00eda reconocible.</p> <p>Variar la frecuencia del PWM para las notas, manteniendo el duty en 50 %.</p> <p>Cada nota debe incluir su frecuencia y duraci\u00f3n en el c\u00f3digo.</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;stdio.h&gt;\n\n#define PIN_BUZZER 0\n#define TOP_PWM 1023\n\n// tempo para esta melod\u00eda (tomado de los datos)\n#define TEMPO 108\n\n// l\u00edmites para clkdiv (RP2040 funciona bien en ~1..255)\n#define CLKDIV_MIN 1.0f\n#define CLKDIV_MAX 255.0f\n\n// duty fijo al 50%\n#define DUTY_50 (TOP_PWM/2)\n\n// estructura para representar una nota: frecuencia en Hz (0 = silencio) y token de duraci\u00f3n\ntypedef struct {\n    int frecuencia;   // Hz (0 = silencio)\n    int token;        // token de duraci\u00f3n (ej. 8 = corchea, -4 = puntillo)\n} Nota;\n\n// --- Melod\u00eda: \"Star Wars theme\" convertida ---\n// Formato: {frecuencia_hz, token_duraci\u00f3n}\n// token: 8 = corchea, 4 = negra, 2 = blanca, 1 = redonda. Token negativo = puntillo (1.5\u00d7).\nstatic const Nota melodia[] = {\n    {466, 8}, {466, 8}, {466, 8}, {698, 2}, {1047, 2},\n    {932, 8}, {880, 8}, {784, 8}, {1397, 2}, {1047, 4},\n    {932, 8}, {880, 8}, {784, 8}, {1397, 2}, {1047, 4},\n    {932, 8}, {880, 8}, {932, 8}, {784, 2},\n    {523, 8}, {523, 8}, {523, 8}, {698, 2}, {1047, 2},\n    {932, 8}, {880, 8}, {784, 8}, {1397, 2}, {1047, 4},\n    {932, 8}, {880, 8}, {784, 8}, {1397, 2}, {1047, 4},\n    {932, 8}, {880, 8}, {932, 8}, {784, 2},\n    {523, -8}, {523, 16}, {587, -4}, {587, 8},\n    {932, 8}, {880, 8}, {784, 8}, {698, 8}, {698, 8},\n    {784, 8}, {880, 8}, {784, 4}, {587, 8}, {659, 4},\n    {523, -8}, {523, 16}, {587, -4}, {587, 8},\n    {932, 8}, {880, 8}, {784, 8}, {698, 8}, {1047, -8}, {784, 16}, {784, 2},\n    {0, 8}, {523, 8}, {587, -4}, {587, 8},\n    {932, 8}, {880, 8}, {784, 8}, {698, 8}, {698, 8},\n    {784, 8}, {880, 8}, {784, 4}, {587, 8}, {659, 4},\n    {1047, -8}, {1047, 16}, {1397, 4}, {1245, 8}, {1109, 4},\n    {1047, 8}, {932, 4}, {831, 8}, {784, 4}, {698, 8}, {1047, 1}\n};\n\nstatic const int MELODIA_LEN = sizeof(melodia) / sizeof(melodia[0]);\n\n// funci\u00f3n auxiliar para limitar un valor float entre dos extremos\nstatic inline float limitar_f(float v, float minimo, float maximo) {\n    if (v &lt; minimo) return minimo;\n    if (v &gt; maximo) return maximo;\n    return v;\n}\n\n// calcula la duraci\u00f3n en milisegundos a partir del tempo y el token de nota\nint calcular_duracion_ms(int tempo, int token) {\n    // nota entera en ms: (60000 / tempo) * 4\n    float nota_entera = (60000.0f / tempo) * 4.0f;\n    float duracion;\n    if (token &gt; 0) {\n        duracion = nota_entera / (float)token;\n    } else {\n        // token negativo = puntillo (1.5x)\n        duracion = nota_entera / (float)(-token);\n        duracion *= 1.5f;\n    }\n    return (int)(duracion + 0.5f);\n}\n\nint main() {\n    stdio_init_all();\n\n    // inicializar PWM en el pin del buzzer\n    gpio_set_function(PIN_BUZZER, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PIN_BUZZER);\n    uint canal = pwm_gpio_to_channel(PIN_BUZZER);\n    pwm_set_wrap(slice, TOP_PWM);\n    pwm_set_chan_level(slice, canal, 0);\n    pwm_set_enabled(slice, true);\n\n    const int tempo = TEMPO;\n\n    while (true) {\n        for (int i = 0; i &lt; MELODIA_LEN; i++) {\n            int freq = melodia[i].frecuencia;\n            int token = melodia[i].token;\n\n            int notaMs = calcular_duracion_ms(tempo, token);\n\n            if (freq == 0) {\n                // silencio\n                pwm_set_chan_level(slice, canal, 0);\n                sleep_ms((int)(notaMs * 0.9f));\n                // peque\u00f1a pausa (10%)\n                sleep_ms((int)(notaMs * 0.1f));\n                continue;\n            }\n\n            // calcular clkdiv para la frecuencia solicitada\n            const float f_clk = 125000000.0f;\n            float clkdiv = f_clk / ((float)freq * (TOP_PWM + 1));\n            clkdiv = limitar_f(clkdiv, CLKDIV_MIN, CLKDIV_MAX);\n            pwm_set_clkdiv(slice, clkdiv);\n\n            // duty al 50%\n            pwm_set_chan_level(slice, canal, DUTY_50);\n\n            // reproducir 90% de la duraci\u00f3n de la nota\n            sleep_ms((int)(notaMs * 0.9f));\n\n            // silencio 10%\n            pwm_set_chan_level(slice, canal, 0);\n            sleep_ms((int)(notaMs * 0.1f));\n        }\n\n        // peque\u00f1a pausa antes de repetir la melod\u00eda completa\n        sleep_ms(1500);\n    }\n\n    return 0;\n}\n</code></pre></p> <p>3) Esquematico de conexion: </p> <p>4) Video:</p>"},{"location":"Sistemas%20embebidos%20l/Tarea%207/#generacion-de-senales-senoidal-de-60-hz-con-pwm-filtro-rc","title":"Generaci\u00f3n de Se\u00f1ales \u2014 Senoidal de 60 Hz con PWM + Filtro RC","text":"<p>1) Que debe hacer:</p> <p>Generar una se\u00f1al sinusoidal aproximada de 60 Hz variando el duty cycle del PWM seg\u00fan una funci\u00f3n seno.</p> <p>Construir un filtro RC pasabajos b\u00e1sico y verificar la se\u00f1al en el osciloscopio:</p> <p>2) Codigo: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define PIN_OUT       0\n#define PWM_RES       1023\n#define WAVE_FREQ     60\n#define TABLE_SIZE    100\n\nuint16_t seno_table[TABLE_SIZE];\n\nint main() {\n    stdio_init_all();\n\n    for (uint i = 0; i &lt; TABLE_SIZE; i++) {\n        double angle = (2.0 * M_PI * i) / (double)TABLE_SIZE;\n        double scaled = (sin(angle) + 1.0) * 0.5;\n        seno_table[i] = (uint16_t)(scaled * PWM_RES);\n    }\n\n    gpio_set_function(PIN_OUT, GPIO_FUNC_PWM);\n    uint slice_num = pwm_gpio_to_slice_num(PIN_OUT);\n    uint channel   = pwm_gpio_to_channel(PIN_OUT);\n\n    pwm_set_wrap(slice_num, PWM_RES);\n    pwm_set_chan_level(slice_num, channel, 0);\n    pwm_set_enabled(slice_num, true);\n\n    double update_rate = WAVE_FREQ * TABLE_SIZE;\n    uint32_t wait_us = (uint32_t)(1000000.0 / update_rate);\n\n    uint idx = 0;\n    while (true) {\n        pwm_set_chan_level(slice_num, channel, seno_table[idx]);\n        idx = (idx + 1) % TABLE_SIZE;\n        sleep_us(wait_us);\n    }\n\n    return 0;\n}\n</code></pre></p> <p>3) Esquematico de conexion: </p> <p>4) Fotos:</p> <p></p>"},{"location":"Sistemas%20embebidos%20l/Tarea%208/","title":"\ud83d\udcda Tarea 8","text":""},{"location":"Sistemas%20embebidos%20l/Tarea%208/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: UART </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 22/10/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestran 2 ejercicios de comunicaci\u00f3n UART entre dos Raspberry Pi Pico 2.</li> </ul>"},{"location":"Sistemas%20embebidos%20l/Tarea%208/#ejercicio-1","title":"Ejercicio 1","text":"<p>1) Que debe hacer: Encender el led conectado a otra Raspberry mediante un bot\u00f3n conectado a la otra Raspbeerry.</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n\n#define UART_ID uart0\n#define BAUD_RATE 9600\n\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n\n#define LED_PIN 15\n#define BUTTON_PIN 16\n\nint main() {\n    stdio_init_all();\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    gpio_init(BUTTON_PIN);\n    gpio_set_dir(BUTTON_PIN, GPIO_IN);\n    gpio_pull_up(BUTTON_PIN);\n\n    bool last_button_state = true;\n    bool led_state = false;\n\n    while (true) {\n        bool button_state = gpio_get(BUTTON_PIN);\n\n        // Si se detecta una pulsaci\u00f3n (de HIGH a LOW)\n        if (last_button_state &amp;&amp; !button_state) {\n            uart_putc(UART_ID, 'T'); // Enviamos el car\u00e1cter 'T' al otro Pico\n            sleep_ms(200); // anti rebote\n        }\n        last_button_state = button_state;\n\n        // Si se recibe un byte por UART\n        if (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == 'T') {\n                led_state = !led_state; // Cambiar estado del LED\n                gpio_put(LED_PIN, led_state);\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre></p> <p>3) Esquematico de conexion: </p> <p>4) Video:</p>"},{"location":"Sistemas%20embebidos%20l/Tarea%208/#ejercicio-2","title":"Ejercicio 2","text":"<p>1) Que debe hacer: Encender el led conectado a otra Raspberry mediante un bot\u00f3n y/o un comando en el Serial Monitor conectado a la otra Raspbeerry.</p> <p>2) Codigo: <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define button_pin 16\n#define led_PIN 15\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    gpio_init(button_pin);\n    gpio_set_dir(button_pin, GPIO_IN);\n    gpio_pull_up(button_pin);\n    gpio_init(led_PIN);\n    gpio_set_dir(led_PIN, GPIO_OUT);\n\n    string c = \"\";\n    string p=\"\";\n    while (true){\n\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            p+= (char)ch;\n            if(ch=='.' || ch=='\\n'){\n                uart_puts(UART_ID, p.c_str());\n                p=\"\";\n            }\n        }\n        int a;\n        if (gpio_get(button_pin) == 0 &amp;&amp; a == 1) {\n            printf(\"Button pressed!\\n\");\n            uart_puts(UART_ID, \"LEDON\\n\");\n            sleep_ms(200); \n        }\n         a= gpio_get(button_pin);\n\n        if (uart_is_readable(uart0)) {\n            char character = uart_getc(uart0);\n            printf(character+\"\\n\");\n            if(character=='\\n' || character=='.'){\n                if (c == \"LEDON\"){\n                    gpio_put(led_PIN, 1);\n                    printf(\"LED is ON\\n\");\n                }\n                else if (c == \"LEDOFF\"){\n                    gpio_put(led_PIN, 0);\n                    printf(\"LED is OFF\\n\");\n                } else if(c==\"Invalid Command\"){\n                    printf(\"Invalid Command\\n\");\n                }\n                else{\n                    uart_puts(UART_ID, \"Invalid Command\\n\");\n                }\n                c = \"\";\n                continue;\n            }\n            else{\n                c += character;\n            }\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n}\n</code></pre></p> <p>3) Esquematico de conexion: Usamos la misma conexi\u00f3n que en el ejercicio 1 </p> <p>4) Video:</p>"},{"location":"Sistemas%20embebidos%20l/Tarea%209/","title":"\ud83d\udcda Tarea 9","text":""},{"location":"Sistemas%20embebidos%20l/Tarea%209/#introduccion","title":"Introducci\u00f3n","text":"<ul> <li>Nombre del proyecto: ADC </li> <li>Equipo / Autor(es): Rodrigo Miranda Flores </li> <li>Curso / Asignatura: Sistemas embebidos 1 </li> <li>Fecha: 05/11/2025 </li> <li>Descripci\u00f3n breve: En este apartado se muestran 2 ejerciciosel primero es un luxometro y el segundo el control de un servomotor, ambos usando ADC.</li> </ul>"},{"location":"Sistemas%20embebidos%20l/Tarea%209/#luxometro","title":"Luxometro","text":"<p>1) Que debe hacer: Crear medidor que marca la luminosidad de 0-100% usando un LDR.</p> <p>2) Codigo: <pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n\n// Configurar el canal ADC a usar\n#define ADC_INPUT 0 // canal 0\n\n#define ADC_MIN 850    // valor cuando tapas la LDR\n#define ADC_MAX 3100   // valor con luz m\u00e1xima\n\nint main() {\n    stdio_init_all();\n    adc_init();\n    // Configura el pin GPIO correspondiente como entrada ADC\n    adc_gpio_init(26); // GPIO26 suele mapear a ADC0 en Pico 2\n    // Seleccionar canal\n    adc_select_input(ADC_INPUT);\n\n    while (true) {\n        uint16_t adc = adc_read(); // 12 bits alineados a 0..4095\n\n        if (adc &lt; ADC_MIN) adc = ADC_MIN;\n        if (adc &gt; ADC_MAX) adc = ADC_MAX;\n\n        // Calcular porcentaje de luz 0\u2013100\n        float luz = (adc - ADC_MIN) * 100.0f / (ADC_MAX - ADC_MIN);\n\n        printf(\"ADC: %u\\tLuz: %.1f%%\\n\", adc, luz);\n        sleep_ms(200);\n\u00a0\u00a0\u00a0\u00a0}\n}\n</code></pre></p> <p>3) Esquematico de conexion: </p> <p>4) Video:</p>"},{"location":"Sistemas%20embebidos%20l/Tarea%209/#control-de-servomotor","title":"Control de Servomotor","text":"<p>1) Que debe hacer: Mover un servo usando un potenciometro y un adc que vaya 0-180 grados.</p> <p>2) Codigo: <pre><code>#include &lt;iostream&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n#include \"hardware/pwm.h\"\n\nusing namespace std;\n\n#define SERVO_PIN 0    \n#define POT_PIN 26      \n\nint main() {\n    stdio_init_all();\n\n   //inicializar ADC\n    adc_init();\n    adc_gpio_init(POT_PIN);\n    adc_select_input(0);\n    adc_set_clkdiv(479.0f);          \n    adc_fifo_setup(true, false, 1, false, false);  \n    adc_fifo_drain();                \n    adc_run(true);                    \n\n   //inicializar PWM para el servo\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice_num = pwm_gpio_to_slice_num(SERVO_PIN); //aplicar configuracion al slice\n\n    pwm_set_clkdiv(slice_num, 64.0f);\n    pwm_set_wrap(slice_num, 39062);  \n//ajustar frecuencia del pwm\n    pwm_set_enabled(slice_num, true);\n\n    while (true) {\n\n        if (adc_fifo_get_level() &gt; 0) { //para ver si hay algo dentro del fifo\n            uint16_t valor_adc = adc_fifo_get();\n\n\n            float duty = 0.025f + (valor_adc / 4095.0f) * 0.1f;\n\n            pwm_set_gpio_level(SERVO_PIN, duty * 39062);\n\n\n        }\n\n        sleep_ms(20);\n    }\n\n\u00a0\u00a0\u00a0\u00a0return\u00a00;\n}\n</code></pre></p> <p>3) Esquematico de conexion: Usamos la misma conexi\u00f3n que en el ejercicio 1 </p> <p>4) Video:</p>"}]}